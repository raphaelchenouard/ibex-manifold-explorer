<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crossfilter2/1.4.3/crossfilter.min.js"></script>
    <script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
    <script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
    <style>
        #drop_zone {
            border: 2px dashed grey;
            width: 300px;
            height: 50px;
            margin: 10px;
        }

        .zoom {
            cursor: move;
            fill: none;
            pointer-events: all;
        }

    </style>
</head>

<body>
    <h1>Manifold Explorer</h1>
    <div id="drop_zone" ondrop="drop_handler(event);" ondragover="dragover_handler(event);" ondragend="dragend_handler(event);">
        <strong>Drag one manifold file here ...</strong>
    </div>
    <div id="explorer">
        <div id="control"></div>
        <div id="info"></div>
    </div>
    <div id="detail"></div>
    <div id="selection">
        <div id="info_selection"></div>
        <div id="detail_selection"></div>
    </div>


    <script>
        var sols = []; // raw solutions
        var var_names = []; // names of variables in the manifold
        var names_id = {};
        var mins = []; // min value for each dimension
        var maxs = []; // max value for each dimension

        var nb_var = 0; // number of dimensions
        var cf; // crossfilter object
        var filter_by_status = []; // crossfilter dimension filtering on status
        var filter_sol = []; // crossfilter dimension used to filter solutions on their bounds
        var plotted_sols = []; // plotted solutions after filtering

        var width, height, margin;
        var xscale, yscale; // d3 scale objects
        var x_dom, y_dom; // current domain for each dimension
        var xratio, yratio; // ratio for scaling width of interval
        var k_zoom = 0.1; // zoom factor
        var k_last = 1; // last zoom factor when using mouse wheel zoom
        var xAxis, yAxis; // d3 axis
        var gX, gY; // svg g tag embedding axis

        var zoom, brush, focus, view; // d3 brush for selection of boxes and d3 focus to highlight mouseover boxes

        var curXDim = 0; // current X dimension
        var curYDim = 1; // current Y dimension

        var status_names = ["Inner", "Boundary", "Unkown", "Pending", "All"];
        var status_codes = {}; // dictionary of status names and codes
        for (var i = 0; i < status_names.length; i++) {
            status_codes[status_names[i]] = i;
        }
        var status_color = ["green", "yellow", "grey", "lightgrey"]; // colors use to fill boxes depending on their status code

        // Generate a string with all values
        sol2string = (sol) => {
            var str = "[" + sol.lowers[0] + "," + sol.uppers[0] + "]";
            for (var i = 1; i < nb_var; i++) {
                str += " x [" + sol.lowers[i] + "," + sol.uppers[i] + "]";
            }
            return str;
        }

        // Generate a string with current dimensions
        printsol = (sol) => {
            var str = "[" + sol.lowers[curXDim] + "," + sol.uppers[curXDim] + "]";
            str += " x [" + sol.lowers[curYDim] + "," + sol.uppers[curYDim] + "]";
            return str;
        }

        // print the result of a filter
        function print_filter(filter) {
            var f = eval(filter);
            if (typeof(f.length) != "undefined") {} else {}
            if (typeof(f.top) != "undefined") {
                f = f.top(Infinity);
            } else {}
            if (typeof(f.dimension) != "undefined") {
                f = f.dimension(function(d) {
                    return "";
                }).top(Infinity);
            } else {}
            //console.log(filter + "(" + f.length + ") = " + JSON.stringify(f).replace("[", "[\n\t").replace(/}\,/g, "},\n\t").replace("]", "\n]"));
        }

        // generate solutions from a buffer, ie. a binary mnf file
        function parse_data_mnf(buffer) {
            try {
                // initialize solutions data arrays
                sols = [];
                mins = [];
                maxs = [];
                // use standard js TextDecoder to process binary data
                var dec = new TextDecoder("utf-8");
                // The file starts with a signature on 20 bytes which should look like: IBEX MANIFOLD FILE  2
                // 2 is a number corresponding to the current version of this format
                // start to read the 19 first bytes
                const signature = dec.decode(buffer.slice(0, 19));
                // use of standard js DataView to convert bytes to numbers (float or integer) or strings
                // we start the view to byte 20 to avoid considering the 19 first bytes
                const view = new DataView(buffer.slice(20));
                // initialization of current cursor in the view
                var cursor = 0;
                // read the current version of the format
                const ver = view.getUint32(cursor, true);
                // Uint32 are stored on 4 bytes
                cursor += 4;
                console.log(signature + ver);

                // read the number of dimensions (ie. variables) of the manifold
                nb_var = view.getUint32(cursor, true);
                cursor += 4;

                // read the number of equations in the problem from which this manifold come from
                const nb_eq = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of inequations in the problem from which this manifold come from
                const nb_ineq = view.getUint32(cursor, true);
                cursor += 4;
                console.log(nb_var + " variables, " + nb_eq + " equalities and " + nb_ineq + " inequalities");

                var_names = [];
                names_id = {};
                var nb_read_var = 0;
                if (ver == 4) { // V4 of manifold format with names for variables
                    var cur_name = "";
                    var ch = dec.decode(buffer.slice(20 + cursor, 21 + cursor)); //dec.decode(bytes);
                    var i_ch = new Uint8Array(buffer.slice(20 + cursor, 21 + cursor));
                    var prev_ich = 1;
                    cursor += 1;
                    while ((i_ch != 0 || prev_ich != 0) && nb_read_var < nb_var) { // The list of names ends with an end of line
                        if (i_ch == 0) { // End of a name
                            var_names.push(cur_name);
                            names_id[cur_name] = var_names.length - 1;
                            cur_name = "";
                            nb_read_var += 1;
                        } else { // A character of the name
                            cur_name += ch;
                        }
                        prev_ich = i_ch;
                        ch = dec.decode(buffer.slice(20 + cursor, 21 + cursor)); //dec.decode(bytes);
                        i_ch = new Uint8Array(buffer.slice(20 + cursor, 21 + cursor));
                        cursor += 1;
                    }
                    console.log("Variables: " + var_names);
                    // One more byte was read
                    cursor -= 1;
                } else { // v2
                    // Creating default names for variables
                    for (var i = 1; i <= nb_var; i++) {
                        var_names.push("x" + i);
                        names_id[cur_name] = var_names.length - 1;
                    }
                }
                // read the solving status that ended with this manifold (see ibex doc for that)
                const result_status = view.getUint32(cursor, true);
                cursor += 4;
                console.log("Result status: " + result_status);

                // read the number of inner boxes
                const nb_inner = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of boundary boxes
                const nb_boundary = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of unknown boxes
                const nb_unknown = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of pending boxes
                const nb_pending = view.getUint32(cursor, true);
                cursor += 4;
                console.log("inner: " + nb_inner + ", boundary: " + nb_boundary + ", unknown: " + nb_unknown + ", pending: " + nb_pending);

                // read the solving time
                const solving_time = view.getFloat64(cursor, true);
                // Float64 (double) are stored on 8 bytes
                cursor += 8;
                // Number of cells used to perform the solving process
                const nb_cells = view.getUint32(cursor, true);
                cursor += 4;
                console.log("Solving time: " + solving_time + "s, number of cells: " + nb_cells);

                // read all the solutions
                for (var i = 0; i < nb_inner + nb_pending + nb_unknown + nb_boundary; i++) {
                    // create a new object to manipulate solutions
                    var sol = new Object();
                    // storing lower and upper bound separately
                    sol.lowers = [];
                    sol.uppers = [];
                    // storing the width of each interval
                    sol.width = [];
                    // read all dimension values
                    for (var j = 0; j < nb_var; j++) {
                        // read the lower bound
                        var low = view.getFloat64(cursor, true);
                        cursor += 8;
                        // read the upper bound
                        var up = view.getFloat64(cursor, true);
                        cursor += 8;
                        sol.lowers.push(low);
                        sol.uppers.push(up);
                        // compute the width
                        sol.width.push(up - low);
                        // search for the min and max values for each dimension
                        if (i == 0) {
                            mins.push(low);
                            maxs.push(up);
                        } else {
                            if (mins[j] > low) {
                                mins[j] = low;
                            }
                            if (maxs[j] < up) {
                                maxs[j] = up;
                            }
                        }
                    }
                    // read the solution status: 0=inner, 1=boundary, 2=unknown, 3=pending
                    sol.status = view.getUint32(cursor, true);
                    cursor += 4;

                    // read data about the number of constants values to achieve proof of solution
                    //var nb_proof = view.getUint32(cursor, true); // unused
                    //cursor += 4;

                    var nb_proof = Math.max(nb_var - nb_eq, 0);
                    if (nb_proof > 0) {
                        for (var k = 0; k < nb_proof; k++) {
                            view.getUint32(cursor, true); // unused
                            cursor += 4;
                        }

                    }

                    if (sol.status > 4 || sol.status < 0) {
                        console.log("ERROR: Wrong status(" + sol.status + ") for current solution(" + i + "): " + sol2string(sol));
                    } else {
                        // adding current solution to the list of all solutions used in further steps
                        sols.push(sol);
                    }
                }
                console.log(sols.length + " solutions read using " + cursor + " Bytes!");
                return 1;
            } catch (err) {
                console.log(`There was an error: ${err}`);
                return 0;
            }
        }



        function parse_cov_list(data, cursor, nb_v, sol_set) {
            var nb_sol;
            // read the number of boxes
            nb_sol = data.getUint32(cursor, true);
            cursor += 4;

            console.log(nb_sol + " solutions to parse!");

            var mins = []; // list of minimums, i.e. lower bounds
            var maxs = []; // list of maximums, i.e. upper bounds

            //sol_set.sols = [];

            sol_set.nb_inner = 0;
            sol_set.nb_boundary = 0;
            sol_set.nb_unknown = nb_sol;
            sol_set.nb_pending = 0;

            // read all the solutions
            for (var i = 0; i < nb_sol; i++) {
                // create a new object to manipulate solutions
                var sol = new Object();
                // storing lower and upper bound separately
                sol.lowers = [];
                sol.uppers = [];
                // storing the width of each interval
                sol.width = [];
                // read all dimension values
                for (var j = 0; j < nb_v; j++) {
                    // read the lower bound
                    var low = data.getFloat64(cursor, true);
                    cursor += 8;
                    // read the upper bound
                    var up = data.getFloat64(cursor, true);
                    cursor += 8;
                    sol.lowers.push(low);
                    sol.uppers.push(up);
                    sol.width.push(up - low);
                    sol.status = 2; // Unkown by default
                    //console.log(i + "," + j + ": [" + low + "," + up + ']');
                    // search for the min and max values for each dimension
                    if (i == 0) {
                        mins.push(low);
                        maxs.push(up);
                    } else {
                        if (mins[j] > low) {
                            mins[j] = low;
                        }
                        if (maxs[j] < up) {
                            maxs[j] = up;
                        }
                    }
                }
                sol_set.sols.push(sol);
            }
            sol_set.mins = mins;
            sol_set.maxs = maxs;
            return cursor;
        }

        function parse_cov_inner(data, cursor, sol_set) {
            //var nb_inner;
            // read the number of boxes
            sol_set.nb_inner = data.getUint32(cursor, true);
            cursor += 4;

            console.log(sol_set.nb_inner + " inner boxes");

            // read all the solutions
            for (var i = 0; i < sol_set.nb_inner; i++) {
                var idx;
                idx = data.getUint32(cursor, true);
                cursor += 4;
                sol_set.sols[idx].status = 0;
            }
            return cursor;
        }

        function parse_cov_boundary(data, cursor, sol_set) {
            var bnd_type;
            bnd_type = data.getUint32(cursor, true);
            cursor += 4;
            //var nb_boundary;
            // read the number of boxes
            sol_set.nb_boundary = data.getUint32(cursor, true);
            cursor += 4;

            console.log(sol_set.nb_boundary + " boundary boxes");

            // read all the solutions
            for (var i = 0; i < sol_set.nb_boundary; i++) {
                var idx;
                idx = data.getUint32(cursor, true);
                cursor += 4;
                sol_set.sols[idx].status = 1;
            }
            return cursor;
        }

        function parse_cov_manifold(data, cursor, sol_set) {
            // read the number of equations in the problem from which this manifold come from
            const nb_eq = data.getUint32(cursor, true);
            cursor += 4;
            sol_set.nb_eq = nb_eq;
            // read the number of inequations in the problem from which this manifold come from
            const nb_ineq = data.getUint32(cursor, true);
            cursor += 4;
            sol_set.nb_ineq = nb_ineq;
            console.log(sol_set.nb_var + " variables, " + nb_eq + " equalities and " + nb_ineq + " inequalities");

            var bnd_type;
            bnd_type = data.getUint32(cursor, true);
            cursor += 4;
            console.log("Boundary type: " + bnd_type);

            var nb_proof = sol_set.nb_var - nb_eq;

            if (nb_eq > 0) {
                var nb_sol;
                // read the number of boxes
                nb_sol = data.getUint32(cursor, true);
                cursor += 4;

                console.log(nb_sol + " certified solutions in manifold");
                sol_set.nb_unknown -= nb_sol;
                sol_set.nb_inner += nb_sol;
                // read all the solutions
                for (var i = 0; i < nb_sol; i++) {
                    var idx;
                    idx = data.getUint32(cursor, true);
                    cursor += 4;

                    //console.log("IBU_" + i + ": " + idx);
                    sol_set.sols[idx].status = 1; // boundary with proved solution
                    if (nb_proof > 0) { //(nb_eq < nb_v) {
                        sol_set.sols[idx].proof = [];

                        //console.log("manifold:" + i);
                        for (var j = 0; j < nb_proof; j++) {
                            sol_set.sols[idx].proof.push(data.getUint32(cursor, true)); // unused
                            sol_set.sols[idx].status = 0;
                            cursor += 4;
                        }
                    }
                    sol_set.sols[idx].unicity = [];
                    for (var k = 0; k < sol_set.nb_var; k++) {
                        // read the lower bound
                        var low = data.getFloat64(cursor, true);
                        cursor += 8;
                        // read the upper bound
                        var up = data.getFloat64(cursor, true);
                        cursor += 8;
                        sol_set.sols[idx].unicity.push([low, up])
                        //console.log("unicity[" + i + "]=" + [low, up].toString());
                    }

                }
            }
            //var nb_bnd;
            // read the number of boxes
            sol_set.nb_boundary = data.getUint32(cursor, true);
            cursor += 4;
            console.log(sol_set.nb_boundary + " boundary boxes in manifold");
            for (var i = 0; i < sol_set.nb_boundary; i++) {
                var idx;
                idx = data.getUint32(cursor, true);
                cursor += 4;
                sol_set.sols[idx].status = 1; // boundary with boundary status proved
                //console.log("IBU_" + i + ": " + idx);

                if (nb_eq > 0 && nb_eq < nb_ineq) {
                    sol_set.sols[idx].proof = [];
                    for (var j = 0; j < nb_proof; j++) {
                        var jdx;
                        jdx = data.getUint32(cursor, true);
                        cursor += 4;
                        //console.log("jdx_" + j + ": " + jdx);
                        sol_set.sols[idx].proof.push(jdx); // unused
                        sol_set.sols[idx].status = 1;
                    }
                }
            }


            return cursor;
        }

        function parse_cov_names(view, cursor, sol_set) {
            var nb_read_var = 0;

            sol_set.var_names = [];
            sol_set.names_id = {};

            var i_ch = view.getUint8(cursor);
            cursor += 1;

            var cur_name = ""; //String.fromCharCode(i_ch);
            var tmp = 0;
            console.log(sol_set.nb_var + " names to read:");
            while (nb_read_var < sol_set.nb_var && tmp < 20) {
                if (i_ch == 0 && cur_name.length > 0) { // End of a name
                    sol_set.var_names.push(cur_name);
                    sol_set.names_id[cur_name] = sol_set.var_names.length - 1;
                    console.log("New name: " + cur_name);
                    cur_name = "";
                    nb_read_var += 1;
                } else { // A character of the name
                    cur_name += String.fromCharCode(i_ch);
                    //console.log("Current name: "+cur_name);
                }
                i_ch = view.getUint8(cursor); // new Uint8Array(data.slice(20 + cursor, 21 + cursor));
                //console.log(i_ch);
                cursor += 1;
                tmp += 1;
            }
            return cursor - 1;
        }


        function parse_cov_solver_data(data, view, cursor, sol_set) {
            /*var dec = new TextDecoder();
            var names_id = {};
            var var_names = [];
            var nb_read_var = 0;
            var cur_name = "";
            var ch = dec.decode(data.slice(20 + cursor, 21 + cursor)); //dec.decode(bytes);
            var i_ch = new Uint8Array(data.slice(20 + cursor, 21 + cursor));
            var prev_ich = 1;
            cursor += 1;
            while ((i_ch != 0 || prev_ich != 0) && nb_read_var < nb_var) { // The list of names ends with an end of line
                if (i_ch == 0) { // End of a name
                    var_names.push(cur_name);
                    names_id[cur_name] = var_names.length - 1;
                    cur_name = "";
                    nb_read_var += 1;
                } else { // A character of the name
                    cur_name += ch;
                }
                prev_ich = i_ch;
                ch = dec.decode(data.slice(20 + cursor, 21 + cursor)); //dec.decode(bytes);
                i_ch = new Uint8Array(data.slice(20 + cursor, 21 + cursor));
                cursor += 1;
            }
            console.log("Variables: " + var_names);
            // One more byte was read
            cursor -= 1;*/
            cursor = parse_cov_names(view, cursor, sol_set);

            // read the solving status that ended with this manifold (see ibex doc for that)
            const result_status = view.getUint32(cursor, true);
            cursor += 4;
            console.log("Result status: " + result_status);
            //sol_set.status = result_status;

            // read the solving time
            const solving_time = view.getFloat64(cursor, true);
            // Float64 (double) are stored on 8 bytes
            cursor += 8;
            // Number of cells used to perform the solving process
            const nb_cells = view.getUint32(cursor, true);
            cursor += 4;
            console.log("Solving time: " + solving_time + "s, number of cells: " + nb_cells);

            //var nb_pending;
            // read the number of boxes
            sol_set.nb_pending = view.getUint32(cursor, true);
            cursor += 4;

            // read all the solutions
            for (var i = 0; i < sol_set.nb_pending; i++) {
                var idx;
                idx = view.getUint32(cursor, true);
                cursor += 4;
                sol_set.sols[idx].status = 3;
            }
            //sol_set.names_id = names_id;
            //sol_set.var_names = var_names;
            return cursor;
        }


        function parse_cov_optim_data(data, view, cursor, sol_set) {
            // TODO: uncomment code when cov optim data has names
            sol_set.var_names = [];
            sol_set.names_id = {};
            cursor += sol_set.nb_var;
            //cursor = parse_cov_names(view,cursor,sol_set);


            // read the optimizing status
            const result_status = view.getUint32(cursor, true);
            cursor += 4;
            console.log("Result status: " + result_status);
            //sol_set.status = result_status;

            // read the covering status
            const covering_status = view.getUint32(cursor, true);
            cursor += 4;
            console.log("Covering status: " + result_status + "(1 <=> covering of the extended space (vars+obj), 0 <=> covering of the original space (variables only))");

            var uplo, uplo_eps, loup;

            uplo = view.getFloat64(cursor, true);
            cursor += 8;
            uplo_eps = view.getFloat64(cursor, true);
            cursor += 8;
            loup = view.getFloat64(cursor, true);
            cursor += 8;

            console.log("uplo: " + uplo + " uplo-of-epsboxes: " + uplo_eps);
            console.log("loup: " + loup);

            var feasible_point; //, loup_point=null;
            feasible_point = view.getUint32(cursor, true);
            cursor += 4;
            if (feasible_point == 1) {
                /*loup_point=new Array();
                for (var i=0;i<sol_set.nb_var+covering_status;i++){
                    loup_point.push(view.getFloat64(cursor, true));
                    cursor += 8;
                }*/
                console.log("Best feasible point found: " + JSON.stringify(sol_set.sols[0]));
            } else {
                console.log("No best feasible point found!");
            }

            // read the solving time
            const solving_time = view.getFloat64(cursor, true);
            // Float64 (double) are stored on 8 bytes
            cursor += 8;
            // Number of cells used to perform the solving process
            const nb_cells = view.getUint32(cursor, true);
            cursor += 4;
            console.log("Solving time: " + solving_time + "s, number of cells: " + nb_cells);

            //sol_set.names_id = names_id;
            //sol_set.var_names = var_names;
            return cursor;
        }


        // return a solution set object from a buffer, ie. a binary mnf file
        function parse_data_cov(buffer) {
            console.log("Parsing Covering binary file...");
            // initialize solutions data arrays
            var sols = []; // list of solutions
            var var_names = []; // names of variables in the manifold
            var names_id = {};
            var mins = []; // list of minimums, i.e. lower bounds
            var maxs = []; // list of maximums, i.e. upper bounds

            sol_set = new Object(); // object to store all data about the solution set

            try {
                // use standard js TextDecoder to process binary data
                var dec = new TextDecoder();
                // The file starts with a signature on 20 bytes which should look like: IBEX MANIFOLD FILE  2
                // 2 is a number corresponding to the current version of this format
                // start to read the 19 first bytes
                const signature = dec.decode(buffer.slice(0, 19));
                // use of standard js DataView to convert bytes to numbers (float or integer) or strings
                // we start the view to byte 20 to avoid considering the 19 first bytes
                const view = new DataView(buffer.slice(20));
                // initialization of current cursor in the view
                var cursor = 0;
                // read the current level of the format (2: Optim, 5: Solver)
                const level = view.getUint32(cursor, true);
                // Uint32 are stored on 4 bytes
                cursor += 4;

                console.log(signature + level);
                sol_set.version = level;

                var format_id = new Array(level + 1);
                var format_ver = new Array(level + 1);

                for (var i = 0; i <= level; i++) {
                    format_id[i] = view.getUint32(cursor, true);
                    cursor += 4;
                }
                for (var i = 0; i <= level; i++) {
                    format_ver[i] = view.getUint32(cursor, true);
                    cursor += 4;
                }

                console.log("Current format identification: " + format_id.toString());
                console.log("Current format version: " + format_ver.toString());

                var nb_var;
                nb_var = view.getUint32(cursor, true);
                cursor += 4;
                console.log(nb_var + " dimensions in covering!");
                sol_set.nb_var = nb_var;

                if (level == 5) { // solver data

                    sol_set.sols = new Array();
                    if (format_id[1] == 0) {
                        cursor = parse_cov_list(view, cursor, nb_var, sol_set);
                        console.log(sol_set.sols.length + " solutions parsed");
                    }
                    try {
                        if (format_id[2] == 0) {
                            cursor = parse_cov_inner(view, cursor, sol_set);
                        }
                        if (format_id[3] == 0) {
                            cursor = parse_cov_boundary(view, cursor, sol_set);
                        }
                        if (format_id[4] == 0) {
                            cursor = parse_cov_manifold(view, cursor, sol_set);
                        }
                        if (format_id[5] == 0) {
                            cursor = parse_cov_solver_data(buffer, view, cursor, sol_set);
                            var_names = sol_set.var_names;
                        }
                    } catch (err) {
                        console.log(`There was an error while parsing Solver COV additional format: ${err}`);
                        //return null;
                    }

                } else if (level == 2) {
                    sol_set.sols = new Array();
                    if (format_id[1] == 0) {
                        cursor = parse_cov_list(view, cursor, nb_var, sol_set);
                        console.log(sol_set.sols.length + " solutions parsed");
                    }
                    try {
                        if (format_id[2] == 1) {
                            cursor = parse_cov_optim_data(buffer, view, cursor, sol_set, nb_var);
                            var_names = sol_set.var_names;
                        }
                    } catch (err) {
                        console.log(`There was an error while parsing Optimizer COV additional format: ${err}`);
                        //return null;
                    }
                }
                console.log(sol_set.sols.length + " solutions read using " + cursor + " Bytes!");
                //return sol_set;
            } catch (err) {
                console.log(`There was an error: ${err}`);
                //return null;
            }

            console.log(JSON.stringify(sol_set));

            return sol_set;
        }




        // update the drawing after an event or change in data
        function update_svg(svg, m_id = "manifold", color = null) {

            // Define scale domain relating to current dimensions
            xscale.domain(x_dom);
            yscale.domain(y_dom);
            // Initialize axis objects left and bottom
            xAxis = d3.axisBottom(xscale).ticks(10);
            yAxis = d3.axisLeft(yscale).ticks(10);
            gX.call(xAxis);
            gY.call(yAxis);
            //console.log("x in [" + mins[curXDim] + "," + maxs[curXDim] + "] - " + (maxs[curXDim] - mins[curXDim]));
            //console.log("y in [" + mins[curYDim] + "," + maxs[curYDim] + "] - " + (maxs[curYDim] - mins[curYDim]));

            // Update axis name
            d3.select("#legend_x").text("x" + curXDim);
            d3.select("#legend_y").text("x" + curYDim);

            // Update ratio to compute width and height of rectangles
            xratio = width / (x_dom[1] - x_dom[0]);
            yratio = height / (y_dom[1] - y_dom[0]);

            // Add data as a sub graphic composed of rectangles
            svg.append('g')
                .attr("id", m_id)
                .attr('transform', "translate(" + margin.left + "," + margin.top + ")") // translate considering the impact of axis
                .selectAll("rect").data(plotted_sols).enter().append("rect")
                .attr("x", (sol) => { // set the upper left corner x coordinate
                    return xscale(sol.lowers[curXDim])
                })
                .attr("y", (sol) => { // set the upper left corner y coordinate
                    return yscale(sol.uppers[curYDim])
                })
                .attr("class", "box")
                .attr("width", (sol) => { // set ther width of rectangle
                    return xratio * sol.width[curXDim]
                })
                .attr("height", (sol) => { // set the height
                    return yratio * sol.width[curYDim]
                })
                .attr("fill", (sol) => {
                    return color != null ? color : status_color[sol.status]
                }).attr("opacity", 0.2) // fill the rectangle with a given color
                .on("mouseover", function(d) { // add the function to call when mouse goes over
                    //Get the rectangle x/y values
                    var xPos = parseFloat(d3.select(this).attr("x"));
                    var yPos = parseFloat(d3.select(this).attr("y"));
                    // show the solution details
                    d3.select("#detail").html("Solution detail (status=" + d.status + "): " + printsol(d));
                    // change the color of rectangle
                    d3.select(this)
                        .attr("fill", "orange")
                        .transition()
                        .duration(250);

                    // update coordinates of dashed lines to project focused box on each axis
                    focus.select('line.x1')
                        .attr('x1', xscale(d.lowers[curXDim]))
                        .attr('x2', xscale(d.lowers[curXDim]))
                        .attr('y1', yscale(d.lowers[curYDim]))
                        .attr('y2', height);
                    focus.select('line.x2')
                        .attr('x1', xscale(d.uppers[curXDim]))
                        .attr('x2', xscale(d.uppers[curXDim]))
                        .attr('y1', yscale(d.lowers[curYDim]))
                        .attr('y2', height);
                    focus.select('line.y1')
                        .attr('x1', 0)
                        .attr('x2', xscale(d.lowers[curXDim]))
                        .attr('y1', yscale(d.lowers[curYDim]))
                        .attr('y2', yscale(d.lowers[curYDim]));
                    focus.select('line.y2')
                        .attr('x1', 0)
                        .attr('x2', xscale(d.lowers[curXDim]))
                        .attr('y1', yscale(d.uppers[curYDim]))
                        .attr('y2', yscale(d.uppers[curYDim]));
                    focus.style('display', null);
                })
                .on("mouseout", function() { // add the function to call when mouse goes out the rectangle
                    // set the initial color
                    d3.select(this)
                        .transition()
                        .duration(250)
                        .attr("fill", (sol) => {
                            return color != null ? color : status_color[sol.status]
                        });
                    // hide dashed lines
                    focus.style('display', 'none');
                    d3.select("#detail").html("");
                });

            // show global information about the manifold and plotted solutions
            d3.select("#info").html(plotted_sols.length + " solutions displayed");
            //svg_str=svg.node().outerHTML;
        }

        function erase_manifold(plot = "#plot_0") {
            //svg.selectAll("#"+m_id).remove();
            d3.select(plot).selectAll("#manifold").remove();
        }

        function reset_selection() {
            console.log("Resetting selection...");
            filter_sol.filterAll();
            plotted_sols = filter_sol.top(Infinity);
            erase_manifold();
            x_dom = [mins[curXDim], maxs[curXDim]];
            y_dom = [mins[curYDim], maxs[curYDim]];
            update_svg(d3.select("#plot_0"));
        }


        // Create the initial drawing with default values
        function create_svg(node, w = 800, h = 600, marg = null) {
            // Define margins for the graphic to place axis
            if (marg == null) {
                margin = {
                    top: 20,
                    right: 20,
                    bottom: 50,
                    left: 70
                };
            } else {
                margin = marg;
            }
            width = w - margin.left - margin.right;
            height = h - margin.top - margin.bottom;
            // create new svg node to store the graphic
            var svg = node.append("svg")
                .attr('xmlns:xlink', 'http://www.w3.org/1999/xlink')
                .attr('width', w)
                .attr('height', h)
                .attr('id', 'plot_0')
                .append('g')
                .attr('id', 'view')
                .attr('transform', "translate(" + margin.left + "," + margin.top + ")");

            // Initialize scale objects
            xscale = d3.scaleLinear().range([0, width]);
            yscale = d3.scaleLinear().range([height, 0]);
            // Initial current domain to min and max  of each dimension
            x_dom = [mins[curXDim], maxs[curXDim]];
            y_dom = [mins[curYDim], maxs[curYDim]];

            // Initialize axis objects left and bottom
            xAxis = d3.axisBottom(xscale).ticks(10);
            yAxis = d3.axisLeft(yscale).ticks(10);
            // Add the x Axis
            gX = svg.append("g")
                .attr("class", "axis axis--x")
                .attr("transform", "translate(" + 0 + "," + height + ")")
                .call(xAxis);
            // Add the y Axis
            gY = svg.append("g")
                .attr("class", "axis axis--y")
                .call(yAxis);
            // text label for the x axis
            svg.append("text")
                .attr("id", "legend_x")
                .attr("transform",
                    "translate(" + (w / 2) + " ," +
                    (height + margin.top + margin.bottom / 2) + ")")
                .style("text-anchor", "middle")
                .text("x" + curXDim);
            // text label for the y axis
            svg.append("text")
                .attr("id", "legend_y")
                //.attr("transform", "rotate(-90)")
                .attr("x", -margin.left / 2)
                .attr("y", h / 2)
                .style("text-anchor", "middle")
                .text("x" + curYDim);

            //view = svg.append("d").attr("id","view");

            // Generate date inside the graphic
            update_svg(d3.select("#plot_0"));

            // Add objects when focus on a box
            focus = svg.append('g')
                .attr('class', 'focus')
                .style('display', 'none');

            focus.append('line')
                .classed('x1', true);
            focus.append('line')
                .classed('x2', true);

            focus.append('line')
                .classed('y1', true);
            focus.append('line')
                .classed('y2', true);

            d3.selectAll('.focus line')
                .style('fill', 'none')
                .style('stroke', 'black')
                .style('stroke-width', '1.5px')
                .style('stroke-dasharray', '3 3')
                .style('opacity', 0.7);

            zoom = d3.zoom()
                .scaleExtent([1, Infinity])
                .translateExtent([
                    [0, 0],
                    [width, height]
                ])
                .extent([
                    [0, 0],
                    [width, height]
                ])
                .on("zoom", zoomed);

            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .call(zoom);

            function zoomed() {
                // TODO
                //console.log(JSON.stringify(d3.event.transform));

                var k = d3.event.transform.k - k_last;

                k_last = d3.event.transform.k;
                var w_x = x_dom[1] - x_dom[0];
                var w_y = y_dom[1] - y_dom[0];
                if (k > 0) {
                    x_dom[0] += w_x * k_zoom;
                    x_dom[1] -= w_x * k_zoom;
                    y_dom[0] += w_y * k_zoom;
                    y_dom[1] -= w_y * k_zoom;
                } else {
                    x_dom[0] -= w_x * k_zoom;
                    x_dom[1] += w_x * k_zoom;
                    y_dom[0] -= w_y * k_zoom;
                    y_dom[1] += w_y * k_zoom;
                }

                filter_sol.filterFunction(function(d) {
                    return ((d.lowers[curXDim] >= x_dom[0] && d.lowers[curXDim] <= x_dom[1]) ||
                            (d.uppers[curXDim] <= x_dom[1] && d.uppers[curXDim] >= x_dom[0])) &&
                        ((d.lowers[curYDim] >= y_dom[0] && d.lowers[curYDim] <= y_dom[1]) ||
                            (d.uppers[curYDim] <= y_dom[1] && (d.uppers[curYDim] >= y_dom[0])));
                });

                // update the set of solution to plot
                plotted_sols = filter_sol.top(Infinity);
                d3.select("#info").html(plotted_sols.length + " solutions displayed");
                // clean current graphic
                erase_manifold();
                // add new data relating to current zoom
                update_svg(d3.select("#plot_0"));
            }
        }


        // Add inputs to update the graphic
        function create_controls(node) {
            // Add a list selection for dimension of x axis
            var selX = node.append('select')
                .attr("id", "selX")
                .style("font-size", "14")
                .attr('class', 'select')
                .on('change', onchangeX);
            selX.selectAll("option")
                .data(var_names).enter()
                .append('option')
                .property('selected', function(d) {
                    return d === var_names[0];
                })
                .text(function(d) {
                    return d;
                })
            // Add a list selection for dimension of y axis
            var selY = node.append('select')
                .attr("id", "selY")
                .attr('class', 'select')
                .on('change', onchangeY);
            selY.selectAll("option")
                .data(var_names).enter()
                .append('option')
                .property('selected', function(d) {
                    return d === var_names[1];
                })
                .text(function(d) {
                    return d;
                });

            // Add a list selection for the status of solutions to plot
            var selStatus = node.append('select')
                .attr("id", "selStatus")
                .attr('class', 'select')
                .on('change', onchangeStatus);
            selStatus.selectAll("option")
                .data(status_names).enter()
                .append('option')
                .property('selected', function(d) {
                    return d === "Inner";
                })
                .text(function(d) {
                    return d;
                });

            var grpBtn = node.append('div').attr("class", 'input-group margin-bottom-sm');


            var crop = grpBtn.append('span')
                .attr('id', 'crop')
                .attr('title', 'Make a rectangular selection')
                .attr('type', 'button')
                //.attr('value', '&#f125')
                .on('click', crop)
                .append('i')
                .attr('class', 'fas fa-crop fa-2x fa-border');

            var zoomIn = grpBtn.append('span')
                .attr('id', 'zoomIn')
                .attr('title', 'Zoom in')
                .on('click', zoom_in)
                .append('i')
                .attr('class', 'fas fa-search-plus fa-2x fa-border');
            var zoomOut = grpBtn.append('span')
                .attr('id', 'zoomOut')
                .attr('title', 'Zoom out')
                .on('click', zoom_out)
                .append('i')
                .attr('class', 'fas fa-search-minus fa-2x fa-border');

            var resSel = grpBtn.append('span')
                .attr('id', 'resBtn')
                .attr('title', 'Reset current selection or zoom')
                .on('click', reset_selection)
                .append('i')
                .attr('class', 'fas fa-undo fa-2x fa-border');

            var expImg = grpBtn.append('span')
                .attr('id', 'expImg')
                .attr('title', 'Export current graphic as image')
                .on('click', export_image)
                .append('i')
                .attr('class', 'fas fa-image fa-2x fa-border');

            var expMnf = grpBtn.append('span')
                .attr('id', 'expMnf')
                .attr('title', 'Export current boxes as manifold')
                .on('click', export_manifold)
                .append('i')
                .attr('class', 'fas fa-save fa-2x fa-border');


            // function called when dimension for x axis change
            function onchangeX() {
                var selectValue = d3.select('#selX').property('value');
                // get the number corresponding to the selection
                //curXDim = parseInt(selectValue.substring(1));
                curXDim = names_id[selectValue];
                // clean current graphic
                erase_manifold();

                var minAcc = function(d) {
                    return d.lowers[curXDim];
                };
                var maxAcc = function(d) {
                    return d.uppers[curXDim];
                };
                x_dom[0] = d3.extent(plotted_sols, minAcc)[0];
                x_dom[1] = d3.extent(plotted_sols, maxAcc)[1];

                //reset_selection();
                // add new data relating to new selected dimension
                update_svg(d3.select("#plot_0"));
            };

            // function called when dimension for y axis change
            function onchangeY() {
                var selectValue = d3.select('#selY').property('value');
                // get the number corresponding to the selection
                //curYDim = parseInt(selectValue.substring(1));
                curYDim = names_id[selectValue];
                // clean current graphic
                erase_manifold();

                var minAcc = function(d) {
                    return d.lowers[curYDim];
                };
                var maxAcc = function(d) {
                    return d.uppers[curYDim];
                };
                y_dom[0] = d3.extent(plotted_sols, minAcc)[0];
                y_dom[1] = d3.extent(plotted_sols, maxAcc)[1];

                //reset_selection();
                // add new data relating to new selected dimension
                update_svg(d3.select("#plot_0"));
            };

            // function called when status change
            function onchangeStatus() {
                var selectValue = d3.select('#selStatus').property('value');
                if (selectValue === "All") {
                    // remove current filter from selected solutions
                    filter_by_status.filterAll();
                } else {
                    // filter solutions on selected status
                    filter_by_status.filterExact(status_codes[selectValue]);
                }
                // update the set of solution to plot
                plotted_sols = filter_by_status.top(Infinity);
                d3.select("#info").html(plotted_sols.length + " solutions displayed");
                // clean current graphic
                erase_manifold();

                var minAcc = function(d) {
                    return d.lowers[curXDim];
                };
                var maxAcc = function(d) {
                    return d.uppers[curXDim];
                };
                x_dom[0] = d3.extent(plotted_sols, minAcc)[0];
                x_dom[1] = d3.extent(plotted_sols, maxAcc)[1];

                //reset_selection();
                // add new data relating to new selected status
                update_svg(d3.select("#plot_0"));
            };


            function crop() {
                // TODO

                if (brush == null) {
                    // Add brush selection
                    brush = d3.brush()
                        .extent([
                            [0, 0],
                            [width, height]
                        ])
                        .on("end", brushed);

                    function brushed() {
                        if (!d3.event.sourceEvent) return; // Only transition after input.
                        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
                        if (d3.event.selection != null) {
                            var selection = d3.event.selection;
                            var x1 = Math.min(xscale.invert(selection[0][0]), xscale.invert(selection[1][0]));
                            var x2 = Math.max(xscale.invert(selection[0][0]), xscale.invert(selection[1][0]));
                            var y1 = Math.min(yscale.invert(selection[0][1]), yscale.invert(selection[1][1]));
                            var y2 = Math.max(yscale.invert(selection[0][1]), yscale.invert(selection[1][1]));

                            filter_sol.filterFunction(function(d) {
                                return d.lowers[curXDim] >= x1 && d.uppers[curXDim] <= x2 && d.lowers[curYDim] >= y1 && d.uppers[curYDim] <= y2;
                            });

                            plotted_sols = filter_sol.top(Infinity);

                            x_dom = [x1, x2];
                            y_dom = [y1, y2];
                            erase_manifold();
                            // Add red boxes for the selection
                            update_svg(d3.select("#plot_0"));
                            // Erase the grey box drawn by brush when selecting
                            d3.selectAll(".brush").call(brush.move, null);

                            var info = d3.select('#info_selection').html(plotted_sols.length + " selected solution(s) within: [" + x1 + "," + x2 + "]x[" + y1 + "," + y2 + "]");
                        }
                    }
                    d3.select("#crop").attr("class", "fas fa-crosshairs").attr("clicked", 1).style("background-color", "grey");
                    d3.select("#plot_0").append("g")
                        .attr("class", "brush")
                        .call(brush);
                } else {
                    if (d3.selectAll("#crop").attr("clicked") == 0) {
                        d3.select("#crop").attr("clicked", 1);
                        console.log("Activating crop");
                        d3.select("#crop").style("background-color", "grey");
                        //d3.select("#crop").attr("class","fas fa-crosshairs").node().toggle();
                        //d3.selectAll("g.brush").call(brush.move,[width,height]);
                        d3.select("#plot_0").append("g")
                            .attr("class", "brush")
                            .call(brush);
                    } else {
                        console.log("Disabling crop");
                        d3.select("#crop").attr("clicked", 0);
                        d3.select("#crop").style("background", "none");
                        //d3.select("#crop").attr("class","fas fa-crop");
                        d3.selectAll("g.brush").remove(); //call(brush.move,null);
                    }

                }

            }


            function zoom_in() {
                var w_x = x_dom[1] - x_dom[0];
                var w_y = y_dom[1] - y_dom[0];
                x_dom[0] += w_x * k_zoom;
                x_dom[1] -= w_x * k_zoom;
                y_dom[0] += w_y * k_zoom;
                y_dom[1] -= w_y * k_zoom;

                filter_sol.filterFunction(function(d) {
                    //return d.lowers[curXDim] >= x_dom[0] && d.uppers[curXDim] <= x_dom[1] && d.lowers[curYDim] >= y_dom[0] && d.uppers[curYDim] <= y_dom[1];
                    return ((d.lowers[curXDim] >= x_dom[0] && d.lowers[curXDim] <= x_dom[1]) ||
                            (d.uppers[curXDim] <= x_dom[1] && d.uppers[curXDim] >= x_dom[0])) &&
                        ((d.lowers[curYDim] >= y_dom[0] && d.lowers[curYDim] <= y_dom[1]) ||
                            (d.uppers[curYDim] <= y_dom[1] && (d.uppers[curYDim] >= y_dom[0])));
                });

                // update the set of solution to plot
                plotted_sols = filter_sol.top(Infinity);
                d3.select("#info").html(plotted_sols.length + " solutions displayed");
                // clean current graphic
                erase_manifold();
                //reset_selection();
                // add new data relating to new selected status
                update_svg(d3.select("#plot_0"));
            }


            function zoom_out() {
                var w_x = x_dom[1] - x_dom[0];
                var w_y = y_dom[1] - y_dom[0];
                x_dom[0] -= w_x * k_zoom;
                x_dom[1] += w_x * k_zoom;
                y_dom[0] -= w_y * k_zoom;
                y_dom[1] += w_y * k_zoom;

                filter_sol.filterFunction(function(d) {
                    //return d.lowers[curXDim] >= x_dom[0] && d.uppers[curXDim] <= x_dom[1] && d.lowers[curYDim] >= y_dom[0] && d.uppers[curYDim] <= y_dom[1];
                    return ((d.lowers[curXDim] >= x_dom[0] && d.lowers[curXDim] <= x_dom[1]) ||
                            (d.uppers[curXDim] <= x_dom[1] && d.uppers[curXDim] >= x_dom[0])) &&
                        ((d.lowers[curYDim] >= y_dom[0] && d.lowers[curYDim] <= y_dom[1]) ||
                            (d.uppers[curYDim] <= y_dom[1] && (d.uppers[curYDim] >= y_dom[0])));
                });

                // update the set of solution to plot
                plotted_sols = filter_sol.top(Infinity);
                d3.select("#info").html(plotted_sols.length + " solutions displayed");
                // clean current graphic
                erase_manifold();
                //reset_selection();
                // add new data relating to new selected status
                update_svg(d3.select("#plot_0"));
            }


            function downloadURL(data, fileName) {
                var a;
                a = document.createElement('a');
                a.href = data;
                a.download = fileName;
                document.body.appendChild(a);
                a.style = 'display: none';
                a.click();
                a.remove();
            };

            function export_image() {
                //get svg element.
                var svg = d3.select("#plot_0").node();
                console.log("Export current graphic as svg file");
                //get svg source.
                var serializer = new XMLSerializer();
                var source = serializer.serializeToString(svg);

                //add name spaces.
                if (!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
                    source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
                }
                if (!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)) {
                    source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
                }

                //add xml declaration
                source = '<?xml version="1.0" standalone="no"?>\r\n' + source;

                //convert svg source to URI data scheme.
                var url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);

                //set url value to a element's href attribute.
                /*var link = d3.select("#info").append("a").attr("href", url).attr("download", "plot.svg"); //.html("download image");
                //document.getElementById("link").href = url;
                //you can download svg file by right click menu.
                link.node().click();
                link.remove();*/
                downloadURL(url, "plot.svg")
            }

            function export_manifold() {
                var sig_str = "IBEX MANIFOLD FILE ";
                var n_int = 11 + plotted_sols.length;
                var n_dbl = 1 + 2 * plotted_sols.length * plotted_sols[0].lowers.length;
                var n_bytes = sig_str.length + 4 * n_int + 8 * n_dbl;
                var buffer = new ArrayBuffer(n_bytes);
                var view = new DataView(buffer);

                var cursor = 0;
                for (var i = 0; i < sig_str.length; i++) {
                    view.setUint8(i, sig_str.charCodeAt(i))
                }
                cursor = sig_str.length + 1;

                view.setUint32(cursor, 2 >>> 0, true); // mnf ver
                cursor += 4;
                view.setUint32(cursor, plotted_sols[0].lowers.length >>> 0, true); // nb var
                cursor += 4;
                view.setUint32(cursor, plotted_sols[0].lowers.length >>> 0, true); // nb eq
                cursor += 4;
                view.setUint32(cursor, 0 >>> 0, true); // nb ineq
                cursor += 4;
                view.setUint32(cursor, 0 >>> 0, true); // search status
                cursor += 4;
                view.setUint32(cursor, 0 >>> 0, true); // nb inner
                cursor += 4;
                view.setUint32(cursor, 0 >>> 0, true); // nb boundary
                cursor += 4;
                view.setUint32(cursor, plotted_sols.length >>> 0, true); // nb unkown
                cursor += 4;
                view.setUint32(cursor, 0 >>> 0, true); // nb pending
                cursor += 4;
                view.setFloat64(cursor, 2.5, true); // time
                cursor += 8;
                view.setUint32(cursor, 0 >>> 0, true); // nb cells
                cursor += 4;
                var k = 0;
                for (let sol of plotted_sols) {
                    k += 1;
                    for (var i = 0; i < sol.lowers.length; i++) {
                        view.setFloat64(cursor, sol.lowers[i], true);
                        cursor += 8;
                        view.setFloat64(cursor, sol.uppers[i], true);
                        cursor += 8;
                    }
                    view.setUint32(cursor, 3 >>> 0, true); // box status: Pending
                    cursor += 4;
                }

                function downloadBlob(data, fileName, mimeType) {
                    var blob, url;
                    blob = new Blob([data], {
                        type: mimeType
                    });
                    console.log("Blob length: " + blob.size);
                    url = window.URL.createObjectURL(blob);
                    downloadURL(url, fileName, mimeType);
                    setTimeout(function() {
                        return window.URL.revokeObjectURL(url);
                    }, 1000);
                };

                console.log("Buffer length: " + buffer.byteLength, " : " + cursor);

                downloadBlob(buffer, 'plot.mnf', 'application/octet-stream');
            }

        }

        // Function that handle the manifold file drop
        function drop_handler(ev) {
            ev.preventDefault();
            console.log("Drop");
            // If dropped items aren't files, reject them
            var dt = ev.dataTransfer;
            if (dt.items) {
                // Use DataTransferItemList interface to access the file(s)
                for (var i = 0; i < dt.items.length; i++) {
                    if (dt.items[i].kind == "file") {
                        // Remove previous elements if a drawing exists
                        d3.select("#explorer").selectAll("svg").remove();
                        d3.select("#explorer").selectAll("select").remove();
                        d3.select("#explorer").selectAll("input").remove();

                        // Process the ith file, normally only 1 file to process
                        var f = dt.items[i].getAsFile();
                        var reader = new FileReader();

                        var ext = f.name.substr(f.name.length - 4, 4);

                        // Function called after data loading achieved
                        reader.onloadend = function() {
                            if (ext == ".mnf") {
                                sol_set = parse_data_mnf(reader.result);
                            } else if (ext == ".cov") {
                                sol_set = parse_data_cov(reader.result);
                            } else {
                                console.log("Wrong file format!");
                            }

                            if (sol_set != null) {
                                sols = sol_set.sols;
                                mins = sol_set.mins;
                                maxs = sol_set.maxs;
                                var_names = sol_set.var_names;
                                names_id = sol_set.names_id;
                                // Initialize crossfilter with read solutions
                                cf = crossfilter(sols);

                                // create filters
                                filter_sol = cf.dimension(function(d) {
                                    return d;
                                });
                                filter_by_status = cf.dimension(function(d) {
                                    return d.status;
                                });
                                // start with inner solutions only
                                filter_by_status.filterExact(0);
                                plotted_sols = filter_by_status.top(Infinity);
                                console.log(plotted_sols.length + " filtered solutions");

                                create_controls(d3.select("#control"));

                                create_svg(d3.select("#explorer"));
                            } else {
                                console.log("Wrong file format!");
                            }
                        }

                        reader.readAsArrayBuffer(f);
                    }
                }
            } else {
                // Use DataTransfer interface to access the file(s)
                for (var i = 0; i < dt.files.length; i++) {
                    console.log("... file[" + i + "].name = " + dt.files[i].name);
                }
            }
        }

        function dragover_handler(ev) {
            // Prevent default select and drag behavior
            ev.preventDefault();
        }

        function dragend_handler(ev) {
            // Remove all of the drag data
            var dt = ev.dataTransfer;
            if (dt.items) {
                // Use DataTransferItemList interface to remove the drag data
                for (var i = 0; i < dt.items.length; i++) {
                    dt.items.remove(i);
                }
            } else {
                // Use DataTransfer interface to remove the drag data
                ev.dataTransfer.clearData();
            }
        }

    </script>
</body>

</html>
