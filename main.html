<html>

<head>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crossfilter2/1.4.3/crossfilter.min.js"></script>
    <script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
    <style>
        #drop_zone {
            border: 2px dashed grey;
            width: 300px;
            height: 50px;
            margin: 10px;
        }

    </style>
</head>

<body>
    <h1>Manifold Explorer</h1>
    <div id="drop_zone" ondrop="drop_handler(event);" ondragover="dragover_handler(event);" ondragend="dragend_handler(event);">
        <strong>Drag one manifold file here ...</strong>
    </div>
    <div id="explorer">
        <div id="control"></div>
        <div id="info"></div>
    </div>
    <div id="detail"></div>
    <div id="selection">
        <div id="info_selection"></div>
        <div id="detail_selection"></div>
    </div>


    <script>
        var sols = []; // raw solutions
        var mins = []; // min value for each dimension
        var maxs = []; // max value for each dimension

        var nb_var = 0; // number of dimensions
        var cf; // crossfilter object
        var filter_by_status = []; // crossfilter dimension filtering on status
        var filter_sol = []; // crossfilter dimension used to filter solutions on their bounds
        var plotted_sols = []; // plotted solutions after filtering

        var width, height, margin;
        var xscale, yscale; // d3 scale objects
        var xratio, yratio; // ratio for scaling width of interval
        var xAxis, yAxis; // d3 axis
        var gX, gY; // svg g tag embedding axis

        var brush, focus; // d3 brush for selection of boxes and d3 focus to highlight mouseover boxes

        var curXDim = 0; // current X dimension
        var curYDim = 1; // current Y dimension

        var status_names = ["Inner", "Boundary", "Unkown", "Pending", "All"];
        var status_codes = {}; // dictionary of status names and codes
        for (var i = 0; i < status_names.length; i++) {
            status_codes[status_names[i]] = i;
        }

        // Generate a string with all values
        sol2string = (sol) => {
            var str = "[" + sol.lowers[0] + "," + sol.uppers[0] + "]";
            for (var i = 1; i < nb_var; i++) {
                str += " x [" + sol.lowers[i] + "," + sol.uppers[i] + "]";
            }
            return str;
        }

        // Generate a string with current dimensions
        printsol = (sol) => {
            var str = "[" + sol.lowers[curXDim] + "," + sol.uppers[curXDim] + "]";
            str += " x [" + sol.lowers[curYDim] + "," + sol.uppers[curYDim] + "]";
            return str;
        }

        // print the result of a filter
        function print_filter(filter) {
            var f = eval(filter);
            if (typeof(f.length) != "undefined") {} else {}
            if (typeof(f.top) != "undefined") {
                f = f.top(Infinity);
            } else {}
            if (typeof(f.dimension) != "undefined") {
                f = f.dimension(function(d) {
                    return "";
                }).top(Infinity);
            } else {}
            console.log(filter + "(" + f.length + ") = " + JSON.stringify(f).replace("[", "[\n\t").replace(/}\,/g, "},\n\t").replace("]", "\n]"));
        }

        // generate solutions from a buffer, ie. a binary mnf file
        function parse_data(buffer) {
            try {
                // initialize solutions data arrays
                sols = [];
                mins = [];
                maxs = [];
                // use standard js TextDecoder to process binary data
                var dec = new TextDecoder();
                // The file starts with a signature on 20 bytes which should look like: IBEX MANIFOLD FILE  2
                // 2 is a number corresponding to the current version of this format
                // start to read the 19 first bytes
                const signature = dec.decode(buffer.slice(0, 19));
                // use of standard js DataView to convert bytes to numbers (float or integer) or strings
                // we start the view to byte 20 to avoid considering the 19 first bytes
                const view = new DataView(buffer.slice(20));
                // initialization of current cursor in the view
                var cursor = 0;
                // read the current version of the format
                const ver = view.getUint32(cursor, true);
                // Uint32 are stored on 4 bytes
                cursor += 4;
                console.log(signature + ver);

                // read the number of dimensions (ie. variables) of the manifold
                nb_var = view.getUint32(cursor, true);
                cursor += 4;

                // read the number of equations in the problem from which this manifold come from
                const nb_eq = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of inequations in the problem from which this manifold come from
                const nb_ineq = view.getUint32(cursor, true);
                cursor += 4;
                console.log(nb_var + " variables, " + nb_eq + " equalities and " + nb_ineq + " inequalities");

                // read the solving status that ended with this manifold (see ibex doc for that)
                const result_status = view.getUint32(cursor, true);
                cursor += 4;
                console.log("Result status: " + result_status);

                // read the number of inner boxes
                const nb_inner = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of boundary boxes
                const nb_boundary = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of unknown boxes
                const nb_unknown = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of pending boxes
                const nb_pending = view.getUint32(cursor, true);
                cursor += 4;
                console.log("inner: " + nb_inner + ", boundary: " + nb_boundary + ", unknown: " + nb_unknown + ", pending: " + nb_pending);

                // read the solving time
                const solving_time = view.getFloat64(cursor, true);
                // Float64 (double) are stored on 8 bytes
                cursor += 8;
                // Number of cells used to perform the solving process
                const nb_cells = view.getUint32(cursor, true);
                cursor += 4;
                console.log("Solving time: " + solving_time + "s, number of cells: " + nb_cells);

                // read all the solutions
                for (var i = 0; i < nb_inner + nb_pending + nb_unknown + nb_boundary; i++) {
                    // create a new object to manipulate solutions
                    var sol = new Object();
                    // storing lower and upper bound separately
                    sol.lowers = [];
                    sol.uppers = [];
                    // storing the width of each interval
                    sol.width = [];
                    // read all dimension values
                    for (var j = 0; j < nb_var; j++) {
                        // read the lower bound
                        var low = view.getFloat64(cursor, true);
                        cursor += 8;
                        // read the upper bound
                        var up = view.getFloat64(cursor, true);
                        cursor += 8;
                        sol.lowers.push(low);
                        sol.uppers.push(up);
                        // compute the width
                        sol.width.push(up - low);
                        // search for the min and max values for each dimension
                        if (i == 0) {
                            mins.push(low);
                            maxs.push(up);
                        } else {
                            if (mins[j] > low) {
                                mins[j] = low;
                            }
                            if (maxs[j] < up) {
                                maxs[j] = up;
                            }
                        }
                    }
                    // read the solution status: 0=inner, 1=boundary, 2=unknown, 3=pending
                    sol.status = view.getUint32(cursor, true);
                    cursor += 4;
                    // read data about the number of constants values to achieve proof of solution
                    var nb_proof = view.getUint32(cursor, true); // unused 
                    cursor += 4;

                    if (sol.status > 4 || sol.status < 0) {
                        console.log("ERROR: Wrong status(" + sol.status + ") for current solution(" + i + "): " + sol2string(sol));
                    } else {
                        // adding current solution to the list of all solutions used in further steps
                        sols.push(sol);
                    }
                }
                console.log(sols.length + " solutions read!");
            } catch (err) {
                console.log(`There was an error: ${err}`);
            }
        }



        // update the drawing after an event or change in data
        function update_svg(svg, m_id = "manifold", color = "green") {

            // Define scale domain relating to current dimensions
            xscale.domain([mins[curXDim], maxs[curXDim]]);
            yscale.domain([mins[curYDim], maxs[curYDim]]);

            console.log("x in [" + mins[curXDim] + "," + maxs[curXDim] + "] - " + (maxs[curXDim] - mins[curXDim]));
            console.log("y in [" + mins[curYDim] + "," + maxs[curYDim] + "] - " + (maxs[curYDim] - mins[curYDim]));

            // Update axis name
            d3.select("#legend_x").text("x" + curXDim);
            d3.select("#legend_y").text("x" + curYDim);

            // Update ratio to compute width and height of rectangles
            var xratio = width / (maxs[curXDim] - mins[curXDim]);
            var yratio = height / (maxs[curYDim] - mins[curYDim]);

            //svg.append('g')
            //    .attr('transform', "translate(" + margin.left + "," + margin.top + ")");
            //console.log(JSON.stringify(plotted_sols));

            // Add data as a sub graphic composed of rectangles
            svg.append('g')
                .attr("id", m_id)
                .attr('transform', "translate(" + margin.left + "," + margin.top + ")") // translate considering the impact of axis
                .selectAll("rect").data(plotted_sols).enter().append("rect")
                .attr("x", (sol) => { // set the upper left corner x coordinate
                    //console.log(JSON.stringify(sol));
                    return xscale(sol.lowers[curXDim])
                })
                .attr("y", (sol) => { // set the upper left corner y coordinate
                    return yscale(sol.uppers[curYDim])
                })
                .attr("class", "box")
                .attr("width", (sol) => { // set ther width of rectangle
                    return xratio * sol.width[curXDim]
                })
                .attr("height", (sol) => { // set the height
                    return yratio * sol.width[curYDim]
                })
                .attr("fill", color).attr("opacity", 0.2) // fill the rectangle with a given color
                .on("mouseover", function(d) { // add the function to call when mouse goes over
                    //Get the rectangle x/y values
                    var xPos = parseFloat(d3.select(this).attr("x"));
                    var yPos = parseFloat(d3.select(this).attr("y"));
                    //console.log(sol2string(d));
                    // show the solution details
                    d3.select("#detail").html("Solution detail (status=" + d.status + "): " + printsol(d));
                    // change the color of rectangle
                    d3.select(this)
                        .attr("fill", "orange")
                        .transition()
                        .duration(250);

                    // update coordinates of dashed lines to project focused box on each axis
                    focus.select('line.x1')
                        .attr('x1', xscale(d.lowers[curXDim]))
                        .attr('x2', xscale(d.lowers[curXDim]))
                        .attr('y1', yscale(d.lowers[curYDim]))
                        .attr('y2', height);
                    focus.select('line.x2')
                        .attr('x1', xscale(d.uppers[curXDim]))
                        .attr('x2', xscale(d.uppers[curXDim]))
                        .attr('y1', yscale(d.lowers[curYDim]))
                        .attr('y2', height);
                    focus.select('line.y1')
                        .attr('x1', 0)
                        .attr('x2', xscale(d.lowers[curXDim]))
                        .attr('y1', yscale(d.lowers[curYDim]))
                        .attr('y2', yscale(d.lowers[curYDim]));
                    focus.select('line.y2')
                        .attr('x1', 0)
                        .attr('x2', xscale(d.lowers[curXDim]))
                        .attr('y1', yscale(d.uppers[curYDim]))
                        .attr('y2', yscale(d.uppers[curYDim]));
                    focus.style('display', null);
                })
                .on("mouseout", function() { // add the function to call when mouse goes out the rectangle
                    // set the initial color
                    d3.select(this)
                        .transition()
                        .duration(250)
                        .attr("fill", color);
                    // hide dashed lines
                    focus.style('display', 'none');
                    d3.select("#detail").html("");
                });

            // show global information about the manifold and plotted solutions
            d3.select("#info").html(plotted_sols.length + " solutions displayed");

        }

        function erase_manifold(plot = "plot_0") {
            d3.select("#manifold").remove();
        }

        function reset_selection() {
            console.log("Resetting selection...");
            filter_sol.filterAll();
            plotted_sols = filter_sol.top(Infinity);
            erase_manifold();
            update_svg(d3.select("#plot_0"));
            //d3.selectAll("g.selection").remove();
            erase_selection();
            d3.select('#info_selection').html("");
        }

        function erase_selection() {
            d3.select("#g_selection").remove();
        }


        // Create the initial drawing with default values
        function create_svg(node, w = 800, h = 600, marg = null) {
            // Define margins for the graphic to place axis
            if (marg == null) {
                margin = {
                    top: 20,
                    right: 20,
                    bottom: 50,
                    left: 70
                };
            } else {
                margin = marg;
            }
            width = w - margin.left - margin.right,
                height = h - margin.top - margin.bottom;
            // create new svg node to store the graphic
            var svg = node.append("svg")
                .attr('xmlns:xlink', 'http://www.w3.org/1999/xlink')
                .attr('width', w)
                .attr('height', h)
                .attr('id', 'plot_0')
                .append('g')
                .attr('transform', "translate(" + margin.left + "," + margin.top + ")");

            // Initialize scale objects
            xscale = d3.scaleLinear().range([-1, width + 1]);
            yscale = d3.scaleLinear().range([height + 1, -1]);

            // Initialize axis objects left and bottom
            xAxis = d3.axisBottom(xscale).ticks(10);
            yAxis = d3.axisLeft(yscale).ticks(10);
            // Add the x Axis
            gX = svg.append("g")
                .attr("transform", "translate(" + 0 + "," + height + ")")
                .call(xAxis);
            // Add the y Axis
            var gY = svg.append("g")
                //.attr("transform", "translate(" + margin.left + "," + 0 + ")")
                .call(yAxis);
            // text label for the x axis
            svg.append("text")
                .attr("id", "legend_x")
                .attr("transform",
                    "translate(" + (w / 2) + " ," +
                    (height + margin.top + margin.bottom / 2) + ")")
                .style("text-anchor", "middle")
                .text("x" + curXDim);
            // text label for the y axis
            svg.append("text")
                .attr("id", "legend_y")
                //.attr("transform", "rotate(-90)")
                .attr("x", -margin.left / 2)
                .attr("y", h / 2)
                .style("text-anchor", "middle")
                .text("x" + curYDim);

            // Generate date inside the graphic
            update_svg(d3.select("#plot_0"));

            // Add brush selection
            brush = d3.brush()
                .extent([
                    [0, 0],
                    [width, height]
                ])
                .on("end", brushed);

            function brushed() {
                if (!d3.event.sourceEvent) return; // Only transition after input.
                if (d3.event.selection != null) {
                    reset_selection();
                    var selection = d3.event.selection;
                    //console.log("brush: " + JSON.stringify(selection));
                    var x1 = Math.min(xscale.invert(selection[0][0]), xscale.invert(selection[1][0]));
                    var x2 = Math.max(xscale.invert(selection[0][0]), xscale.invert(selection[1][0]));
                    var y1 = Math.min(yscale.invert(selection[0][1]), yscale.invert(selection[1][1]));
                    var y2 = Math.max(yscale.invert(selection[0][1]), yscale.invert(selection[1][1]));

                    //console.log("Brush from (" + x1 + "x" + y1 + ") to (" + x2 + "x" + y2 + ")");

                    filter_sol.filterFunction(function(d) {
                        //console.log(JSON.stringify(d));
                        return d.lowers[curXDim] >= x1 && d.uppers[curXDim] <= x2 && d.lowers[curYDim] >= y1 && d.uppers[curYDim] <= y2;
                    });

                    //d3.select("#manifold").remove();
                    //var selected = filter_sol.top(Infinity);
                    //svg.selectAll("rect").data(selected).enter().attr("fill", "red");
                    plotted_sols = filter_sol.top(Infinity);
                    var node = d3.select("#plot_0");
                    // Add red boxes for the selection
                    update_svg(d3.select("#plot_0"), "g_selection", "red");
                    // Erase the grey box drawn by brush when selecting
                    d3.selectAll(".brush").call(brush.move, null);

                    var info = d3.select('#info_selection').html("Active selection with "+plotted_sols.length + " solution(s) being selected!");
                }
            }

            svg.append("g")
                .attr("class", "brush")
                .call(brush);

            // Add objects when focus on a box
            focus = svg.append('g')
                .attr('class', 'focus')
                .style('display', 'none');

            focus.append('line')
                .classed('x1', true);
            focus.append('line')
                .classed('x2', true);

            focus.append('line')
                .classed('y1', true);
            focus.append('line')
                .classed('y2', true);

            d3.selectAll('.focus line')
                .style('fill', 'none')
                .style('stroke', 'black')
                .style('stroke-width', '1.5px')
                .style('stroke-dasharray', '3 3')
                .style('opacity', 0.7);

            /*var zoom = d3.zoom()
                .scaleExtent([1, 10])
                .translateExtent([
                    [-100, -100],
                    [width + 90, height + 100]
                ])
                .on("zoom", zoomed);*/

            /*var view = svg.append("rect")
                .attr("class", "view")
                .attr("x", 0.5)
                .attr("y", 0.5)
                .attr("width", width - 1)
                .attr("height", height - 1)
                .attr("fill", "grey")
                .attr("opacity", "0.2")
                .attr("stroke","#000");

            function zoomed() {
                view.attr("transform", d3.event.transform);
                gX.call(xAxis.scale(d3.event.transform.rescaleX(xscale)));
                gY.call(yAxis.scale(d3.event.transform.rescaleY(yscale)));
            }

            d3.select("button")
                .on("click", resetted);

            function resetted() {
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);
            }

            svg.call(zoom);*/
        }


        // Add inputs to update the graphic
        function create_controls(node) {
            // Since manifold format does not contains names for dimensions, define some generic ones
            var dim_names = [];
            for (var i = 0; i < nb_var; i++) {
                dim_names.push("x" + i);
            }
            //console.log(dim_names.toString());
            // Add a list selection for dimension of x axis
            var selX = node.append('select')
                .attr("id", "selX")
                .attr('class', 'select')
                .on('change', onchangeX);
            selX.selectAll("option")
                .data(dim_names).enter()
                .append('option')
                .property('selected', function(d) {
                    return d === "x0";
                })
                .text(function(d) {
                    return d;
                })
            // Add a list selection for dimension of y axis
            var selY = node.append('select')
                .attr("id", "selY")
                .attr('class', 'select')
                .on('change', onchangeY);
            selY.selectAll("option")
                .data(dim_names).enter()
                .append('option')
                .property('selected', function(d) {
                    return d === "x1";
                })
                .text(function(d) {
                    return d;
                });

            // Add a list selection for the status of solutions to plot
            var selStatus = node.append('select')
                .attr("id", "selStatus")
                .attr('class', 'select')
                .on('change', onchangeStatus);
            selStatus.selectAll("option")
                .data(status_names).enter()
                .append('option')
                .property('selected', function(d) {
                    return d === "Inner";
                })
                .text(function(d) {
                    return d;
                });

            var resSel = node.append('input')
                .attr('id', 'resBtn')
                .attr('value', 'Reset selection')
                .attr('type', 'button')
                .on('click', reset_selection);


            // function called when dimension for x axis change
            function onchangeX() {
                var selectValue = d3.select('#selX').property('value');
                // get the number corresponding to the selection
                curXDim = parseInt(selectValue.substring(1));
                // clean current graphic
                erase_manifold();
                //d3.select("#manifold").remove();
                erase_selection();
                // add new data relating to new selected dimension
                update_svg(d3.select("#plot_0"));
            };

            // function called when dimension for y axis change
            function onchangeY() {
                var selectValue = d3.select('#selY').property('value');
                // get the number corresponding to the selection
                curYDim = parseInt(selectValue.substring(1));
                // clean current graphic
                erase_manifold();
                //d3.select("#manifold").remove();
                erase_selection();
                // add new data relating to new selected dimension
                update_svg(d3.select("#plot_0"));
            };

            // function called when status change
            function onchangeStatus() {
                var selectValue = d3.select('#selStatus').property('value');
                if (selectValue === "All") {
                    // remove current filter from selected solutions
                    filter_by_status.filterAll();
                } else {
                    // filter solutions on selected status
                    /*filter_by_status.filterFunction((d) => {
                        console.log("Current status: "+d);
                        return d === status_codes[selectValue];
                    });*/
                    filter_by_status.filterExact(status_codes[selectValue]);
                }
                // update the set of solution to plot
                plotted_sols = filter_by_status.top(Infinity);
                //console.log("sols: " + JSON.stringify(plotted_sols));
                d3.select("#info").html(plotted_sols.length + " solutions displayed");
                // clean current graphic
                erase_manifold();
                //d3.select("#manifold").remove();
                erase_selection();
                // add new data relating to new selected status
                update_svg(d3.select("#plot_0"));
            };
        }


        // Function that handle the manifold file drop
        function drop_handler(ev) {
            ev.preventDefault();
            console.log("Drop");
            // If dropped items aren't files, reject them
            var dt = ev.dataTransfer;
            if (dt.items) {
                // Use DataTransferItemList interface to access the file(s)
                for (var i = 0; i < dt.items.length; i++) {
                    if (dt.items[i].kind == "file") {
                        // Remove previous elements if a drawing exists
                        d3.select("#explorer").selectAll("svg").remove();
                        d3.select("#explorer").selectAll("select").remove();

                        // Process the ith file, normally only 1 file to process
                        var f = dt.items[i].getAsFile();
                        //console.log("... file[" + i + "].name = " + f.name);
                        var reader = new FileReader();

                        // Function called after data loading achieved
                        reader.onloadend = function() {
                            //console.log(reader.result);
                            parse_data(reader.result);

                            // Initialize crossfilter with read solutions
                            cf = crossfilter(sols);

                            // create filters
                            filter_sol = cf.dimension(function(d) {
                                /*var d_ = new Object();
                                d_.lowers = d.lowers;
                                d_.uppers = d.uppers;
                                d_.status = d.status;
                                return d_;*/
                                return d;
                            });
                            filter_by_status = cf.dimension(function(d) {
                                return d.status;
                            });
                            // start with inner solutions only
                            filter_by_status.filterExact(0);
                            plotted_sols = filter_by_status.top(Infinity);
                            console.log(plotted_sols.length + " filtered solutions");

                            create_controls(d3.select("#control"));

                            create_svg(d3.select("#explorer"));
                        }

                        reader.readAsArrayBuffer(f);
                    }
                }
            } else {
                // Use DataTransfer interface to access the file(s)
                for (var i = 0; i < dt.files.length; i++) {
                    console.log("... file[" + i + "].name = " + dt.files[i].name);
                }
            }
        }

        function dragover_handler(ev) {
            //console.log("dragOver");
            // Prevent default select and drag behavior
            ev.preventDefault();
        }

        function dragend_handler(ev) {
            //console.log("dragEnd");
            // Remove all of the drag data
            var dt = ev.dataTransfer;
            if (dt.items) {
                // Use DataTransferItemList interface to remove the drag data
                for (var i = 0; i < dt.items.length; i++) {
                    dt.items.remove(i);
                }
            } else {
                // Use DataTransfer interface to remove the drag data
                ev.dataTransfer.clearData();
            }
        }

    </script>
</body>

</html>
