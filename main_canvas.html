<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crossfilter2/1.4.3/crossfilter.min.js"></script>
    <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>
    <script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
    <style>
        #drop_zone {
            border: 2px dashed grey;
            width: 300px;
            height: 50px;
            margin: 10px;
        }

        .zoom {
            cursor: move;
            fill: none;
            pointer-events: all;
        }

        canvas {
            border: 1px dotted #ccc;
        }

        #hiddenCanvas {
            /*display: none;*/
            z-index: 3;
        }

        div#tooltip {
            position: absolute;
            display: inline-block;
            padding: 10px;
            font-family: 'Open Sans'sans-serif;
            color: #000;
            background-color: #fff;
            border: 1px solid #999;
            border-radius: 2px;
            pointer-events: none;
            opacity: 0;
            z-index: 1;
        }

        .plot {
            position: absolute;
        }

        #canvas_plot {
            z-index: 2;
        }

        #empty_svg {
            z-index: 1;
        }

    </style>
</head>

<body>
    <h1>Manifold Explorer</h1>
    <div id="drop_zone" ondrop="drop_handler(event);" ondragover="dragover_handler(event);" ondragend="dragend_handler(event);">
        <strong>Drag one manifold file here ...</strong>
    </div>
    <div id="explorer">
        <div id="control"></div>
        <div id="info"></div>
        <svg id="empty_svg" class="plot"></svg>
        <canvas id="canvas_plot" class="plot"></canvas>
        <canvas id="hiddenCanvas" class="plot"></canvas>
        <div id="tooltip">hello</div>
    </div>
    <div id="detail"></div>
    <div id="selection">
        <div id="info_selection"></div>
        <div id="detail_selection"></div>
    </div>


    <script>
        var sols = []; // raw solutions
        var var_names = []; // names of variables in the manifold
        var names_id = {};
        var mins = []; // min value for each dimension
        var maxs = []; // max value for each dimension

        var nb_var = 0; // number of dimensions
        var cf; // crossfilter object
        var filter_by_status = []; // crossfilter dimension filtering on status
        var filter_sol = []; // crossfilter dimension used to filter solutions on their bounds
        var plotted_sols = []; // plotted solutions after filtering

        var width, height, margin;
        var xscale, yscale; // d3 scale objects
        var x_dom, y_dom; // current domain for each dimension
        var xratio, yratio; // ratio for scaling width of interval
        var xAxis, yAxis;

        var k_zoom = 0.1; // zoom factor
        var k_last = 1; // last zoom factor when using mouse wheel zoom


        var curXDim = 0; // current X dimension
        var curYDim = 1; // current Y dimension

        var status_names = ["Inner", "Boundary", "Unkown", "Pending", "All"];
        var status_codes = {}; // dictionary of status names and codes
        for (var i = 0; i < status_names.length; i++) {
            status_codes[status_names[i]] = i;
        }
        var status_color = ["green", "yellow", "grey", "lightgrey"]; // colors use to fill boxes depending on their status code

        var canvas_color = [
            [0, 255, 0, .2],
            [255, 0, 0, .2],
            [0, 0, 255, .2],
            [125, 125, 125, .2]
        ];
        var canvas, hiddenCanvas;
        var custom = null;
        canvas = d3.select("#canvas_plot");
        hiddenCanvas = d3.select("#hiddenCanvas");
        /*d3.select('#explorer')
                    .append('canvas')
                    .attr('id','hiddenCanvas');*/

        var focus = null;

        var nextCol = 1;
        var colourToNode = {
            //'rgb(0,0,0)': null
        }; // Map to track the colour of nodes.

        // Generate a unique color for each object being drawn in hidden canvas
        function genColor() {
            var ret = [];
            if (nextCol < 16777215) {
                ret.push(nextCol & 0xff); // R 
                ret.push((nextCol & 0xff00) >> 8); // G 
                ret.push((nextCol & 0xff0000) >> 16); // B

                nextCol += 1;
            }
            var col = "rgb(" + ret.join(',') + ")";
            return col;
        }


        // Generate a string with all values
        sol2string = (sol) => {
            var str = "[" + sol.lowers[0] + "," + sol.uppers[0] + "]";
            for (var i = 1; i < nb_var; i++) {
                str += " x [" + sol.lowers[i] + "," + sol.uppers[i] + "]";
            }
            return str;
        }

        // Generate a string with current dimensions
        printsol = (sol) => {
            var str = "[" + sol.lowers[curXDim] + "," + sol.uppers[curXDim] + "]";
            str += " x [" + sol.lowers[curYDim] + "," + sol.uppers[curYDim] + "]";
            return str;
        }

        // print the result of a filter
        function print_filter(filter) {
            var f = eval(filter);
            if (typeof(f.length) != "undefined") {} else {}
            if (typeof(f.top) != "undefined") {
                f = f.top(Infinity);
            } else {}
            if (typeof(f.dimension) != "undefined") {
                f = f.dimension(function(d) {
                    return "";
                }).top(Infinity);
            } else {}
            //console.log(filter + "(" + f.length + ") = " + JSON.stringify(f).replace("[", "[\n\t").replace(/}\,/g, "},\n\t").replace("]", "\n]"));
        }

        // generate solutions from a buffer, ie. a binary mnf file
        function parse_data_ibex(buffer) {
            try {
                // initialize solutions data arrays
                sols = [];
                mins = [];
                maxs = [];
                // use standard js TextDecoder to process binary data
                var dec = new TextDecoder();
                // The file starts with a signature on 20 bytes which should look like: IBEX MANIFOLD FILE  2
                // 2 is a number corresponding to the current version of this format
                // start to read the 19 first bytes
                const signature = dec.decode(buffer.slice(0, 19));
                // use of standard js DataView to convert bytes to numbers (float or integer) or strings
                // we start the view to byte 20 to avoid considering the 19 first bytes
                const view = new DataView(buffer.slice(20));
                // initialization of current cursor in the view
                var cursor = 0;
                // read the current version of the format
                const ver = view.getUint32(cursor, true);
                // Uint32 are stored on 4 bytes
                cursor += 4;
                console.log(signature + ver);

                // read the number of dimensions (ie. variables) of the manifold
                nb_var = view.getUint32(cursor, true);
                cursor += 4;

                // read the number of equations in the problem from which this manifold come from
                const nb_eq = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of inequations in the problem from which this manifold come from
                const nb_ineq = view.getUint32(cursor, true);
                cursor += 4;
                console.log(nb_var + " variables, " + nb_eq + " equalities and " + nb_ineq + " inequalities");

                var_names = [];
                names_id = {};
                var nb_read_var = 0;
                if (ver == 4) { // V4 of manifold format with names for variables
                    var cur_name = "";
                    var ch = dec.decode(buffer.slice(20 + cursor, 21 + cursor)); //dec.decode(bytes);
                    var i_ch = new Uint8Array(buffer.slice(20 + cursor, 21 + cursor));
                    var prev_ich = 1;
                    cursor += 1;
                    while ((i_ch != 0 || prev_ich != 0) && nb_read_var < nb_var) { // The list of names ends with an end of line
                        if (i_ch == 0) { // End of a name
                            var_names.push(cur_name);
                            names_id[cur_name] = var_names.length - 1;
                            cur_name = "";
                            nb_read_var += 1;
                        } else { // A character of the name
                            cur_name += ch;
                        }
                        prev_ich = i_ch;
                        ch = dec.decode(buffer.slice(20 + cursor, 21 + cursor)); //dec.decode(bytes);
                        i_ch = new Uint8Array(buffer.slice(20 + cursor, 21 + cursor));
                        cursor += 1;
                    }
                    console.log("Variables: " + var_names);
                    // One more byte was read
                    cursor -= 1;
                } else { // v2
                    // Creating default names for variables
                    for (var i = 1; i <= nb_var; i++) {
                        var_names.push("x" + i);
                        names_id[cur_name] = var_names.length - 1;
                    }
                }
                // read the solving status that ended with this manifold (see ibex doc for that)
                const result_status = view.getUint32(cursor, true);
                cursor += 4;
                console.log("Result status: " + result_status);

                // read the number of inner boxes
                const nb_inner = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of boundary boxes
                const nb_boundary = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of unknown boxes
                const nb_unknown = view.getUint32(cursor, true);
                cursor += 4;
                // read the number of pending boxes
                const nb_pending = view.getUint32(cursor, true);
                cursor += 4;
                console.log("inner: " + nb_inner + ", boundary: " + nb_boundary + ", unknown: " + nb_unknown + ", pending: " + nb_pending);

                // read the solving time
                const solving_time = view.getFloat64(cursor, true);
                // Float64 (double) are stored on 8 bytes
                cursor += 8;
                // Number of cells used to perform the solving process
                const nb_cells = view.getUint32(cursor, true);
                cursor += 4;
                console.log("Solving time: " + solving_time + "s, number of cells: " + nb_cells);

                // read all the solutions
                for (var i = 0; i < nb_inner + nb_pending + nb_unknown + nb_boundary; i++) {
                    // create a new object to manipulate solutions
                    var sol = new Object();
                    // storing lower and upper bound separately
                    sol.lowers = [];
                    sol.uppers = [];
                    // storing the width of each interval
                    sol.width = [];
                    // read all dimension values
                    for (var j = 0; j < nb_var; j++) {
                        // read the lower bound
                        var low = view.getFloat64(cursor, true);
                        cursor += 8;
                        // read the upper bound
                        var up = view.getFloat64(cursor, true);
                        cursor += 8;
                        sol.lowers.push(low);
                        sol.uppers.push(up);
                        // compute the width
                        sol.width.push(up - low);
                        // search for the min and max values for each dimension
                        if (i == 0) {
                            mins.push(low);
                            maxs.push(up);
                        } else {
                            if (mins[j] > low) {
                                mins[j] = low;
                            }
                            if (maxs[j] < up) {
                                maxs[j] = up;
                            }
                        }
                    }
                    // read the solution status: 0=inner, 1=boundary, 2=unknown, 3=pending
                    sol.status = view.getUint32(cursor, true);
                    cursor += 4;

                    // read data about the number of constants values to achieve proof of solution
                    //var nb_proof = view.getUint32(cursor, true); // unused
                    //cursor += 4;

                    var nb_proof = Math.max(nb_var - nb_eq, 0);
                    if (nb_proof > 0) {
                        for (var k = 0; k < nb_proof; k++) {
                            view.getUint32(cursor, true); // unused
                            cursor += 4;
                        }

                    }

                    if (sol.status > 4 || sol.status < 0) {
                        console.log("ERROR: Wrong status(" + sol.status + ") for current solution(" + i + "): " + sol2string(sol));
                    } else {
                        // adding current solution to the list of all solutions used in further steps
                        sols.push(sol);
                    }
                }
                console.log(sols.length + " solutions read using " + cursor + " Bytes!");
                return 1;
            } catch (err) {
                console.log(`There was an error: ${err}`);
                return 0;
            }
        }



        // update the drawing after an event or change in data
        function update_plot_info() {
            // Define scale domain relating to current dimensions
            xscale.domain(x_dom);
            yscale.domain(y_dom);
            // Initialize axis objects left and bottom
            xAxis = d3.axisBottom(xscale).ticks(10);
            yAxis = d3.axisLeft(yscale).ticks(10);

            // Update ratio to compute width and height of rectangles
            xratio = width / (x_dom[1] - x_dom[0]);
            yratio = height / (y_dom[1] - y_dom[0]);

            // show global information about the manifold and plotted solutions
            d3.select("#info").html(plotted_sols.length + " solutions displayed");
            //svg_str=svg.node().outerHTML;
        }

        function reset_selection() {
            console.log("Resetting selection...");
            filter_sol.filterAll();
            plotted_sols = filter_sol.top(Infinity);
            x_dom = [mins[curXDim], maxs[curXDim]];
            y_dom = [mins[curYDim], maxs[curYDim]];

            update_plot_info();
            data_bind(plotted_sols);
            draw(canvas);
            draw(hiddenCanvas, true);
        }




        // Create the initial drawing with default values
        function create_plot(w = 800, h = 600, marg = null) {
            // Define margins for the graphic to place axis
            if (marg == null) {
                margin = {
                    top: 10,
                    right: 20,
                    bottom: 40,
                    left: 50
                };
            } else {
                margin = marg;
            }
            width = w - margin.left - margin.right;
            height = h - margin.top - margin.bottom;

            //canvas = d3.select("canvas");
            //canvas = d3.select("#explorer").append("canvas").attr("id", "canvas_plot");
            //canvas = d3.select("#canvas_plot");

            canvas.attr('width', w);
            canvas.attr('height', h);
            canvas.node().getContext("2d").translate(margin.left, margin.top);

            hiddenCanvas.attr('width', w)
                .attr('height', h);
            hiddenCanvas.node().getContext("2d").translate(margin.left, margin.top);

            var svg = d3.select("#empty_svg")
                .attr("width", w)
                .attr("height", h)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Initialize scale objects
            xscale = d3.scaleLinear().range([0, width]);
            yscale = d3.scaleLinear().range([height, 0]);
            // Initial current domain to min and max  of each dimension
            x_dom = [mins[curXDim], maxs[curXDim]];
            y_dom = [mins[curYDim], maxs[curYDim]];

            // Update ratio to compute width and height of rectangles
            xratio = width / (x_dom[1] - x_dom[0]);
            yratio = height / (y_dom[1] - y_dom[0]);
            // Initialize axis objects left and bottom
            //xAxis = d3.axisBottom(xscale).ticks(10);
            //yAxis = d3.axisLeft(yscale).ticks(10);

            // create zoom behaviour
            var zoom = d3.zoom()
                .scaleExtent([1, 40])
                .on("zoom", onZoom);

            function onZoom() {
                canvas.attr("transform", d3.event.transform);
                update_plot_info();
                data_bind(plotted_sols);
                draw(canvas);
                draw(hiddenCanvas, true);
            }

            // add zoom behaviour
            canvas.call(zoom);

            update_plot_info();
            data_bind(plotted_sols);
            draw(canvas);
            draw(hiddenCanvas, true);


            d3.select('#canvas_plot').on('mousemove', function() {
                draw(hiddenCanvas, true); // Draw the hidden canvas.
                // Get mouse positions from the main canvas.
                var mouseX = d3.event.clientX;
                var mouseY = d3.event.clientY;

                var rect = canvas.node().getBoundingClientRect();
                mouseX -= rect.left;
                mouseY -= rect.top;

                // Get the toolbox for the hidden canvas.
                var hiddenCtx = hiddenCanvas.node().getContext('2d');

                // Pick the colour from the mouse position. 
                var col = hiddenCtx.getImageData(mouseX, mouseY, 1, 1).data;

                // Then stringify the values in a way our map-object can read it.
                var colKey = 'rgb(' + col[0] + ',' + col[1] + ',' + col[2] + ')';

                // Get the data from our map! 
                var nodeData = colourToNode[colKey];
                if (nodeData) {
                    d3.select('#tooltip')
                        .style('opacity', 0.8)
                        .style('top', d3.event.pageY + 5 + 'px')
                        .style('left', d3.event.pageX + 5 + 'px')
                        .html(printsol(nodeData));
                    if (focus != nodeData) {
                        //console.log(nodeData);
                        var ctx = canvas.node().getContext('2d');
                        if (focus != null) {
                            ctx.clearRect(xscale(focus.lowers[curXDim]), yscale(focus.uppers[curYDim]), xratio * focus.width[curXDim], yratio * focus.width[curYDim]);
                            ctx.fillStyle = 'rgba(' + canvas_color[focus.status] + ')';
                            ctx.fillRect(xscale(focus.lowers[curXDim]), yscale(focus.uppers[curYDim]), xratio * focus.width[curXDim], yratio * focus.width[curYDim]);
                        }
                        focus = nodeData;
                        ctx.clearRect(xscale(focus.lowers[curXDim]), yscale(focus.uppers[curYDim]), xratio * focus.width[curXDim], yratio * focus.width[curYDim]);
                        ctx.fillStyle = 'rgba(200,50,50,0.2)';
                        ctx.fillRect(xscale(focus.lowers[curXDim]), yscale(focus.uppers[curYDim]), xratio * focus.width[curXDim], yratio * focus.width[curYDim]);
                    }
                } else {
                    // Hide the tooltip when the mouse doesn't find nodeData.

                    d3.select('#tooltip').style('opacity', 0);

                }

            });

            canvas.call(d3.zoom().scaleExtent([1, 8]).on("zoom", zoom));


            function zoom() {
                var k = d3.event.transform.k - k_last;

                k_last = d3.event.transform.k;
                var w_x = x_dom[1] - x_dom[0];
                var w_y = y_dom[1] - y_dom[0];
                if (k > 0) {
                    x_dom[0] += w_x * k_zoom;
                    x_dom[1] -= w_x * k_zoom;
                    y_dom[0] += w_y * k_zoom;
                    y_dom[1] -= w_y * k_zoom;
                } else {
                    x_dom[0] -= w_x * k_zoom;
                    x_dom[1] += w_x * k_zoom;
                    y_dom[0] -= w_y * k_zoom;
                    y_dom[1] += w_y * k_zoom;
                }

                filter_sol.filterFunction(function(d) {
                    return ((d.lowers[curXDim] >= x_dom[0] && d.lowers[curXDim] <= x_dom[1]) ||
                            (d.uppers[curXDim] <= x_dom[1] && d.uppers[curXDim] >= x_dom[0])) &&
                        ((d.lowers[curYDim] >= y_dom[0] && d.lowers[curYDim] <= y_dom[1]) ||
                            (d.uppers[curYDim] <= y_dom[1] && (d.uppers[curYDim] >= y_dom[0])));
                });

                // update the set of solution to plot
                plotted_sols = filter_sol.top(Infinity);
                //d3.select("#info").html(plotted_sols.length + " solutions displayed");
                update_plot_info();
                data_bind(plotted_sols);
                draw(canvas);
                draw(hiddenCanvas, true);
            }
        }

        function data_bind(data_plot) {
            var customBase = document.createElement("custom");
            custom = d3.select(customBase);

            custom.selectAll('custom.box')
                .data(data_plot)
                .enter()
                .append("custom")
                .attr("class", "box")
                .attr("x", (d) => xscale(d.lowers[curXDim]))
                .attr("y", (d) => yscale(d.uppers[curYDim]))
                .attr("width", (d) => xratio * d.width[curXDim])
                .attr("height", (d) => yratio * d.width[curYDim])
                .attr("fillStyle", (d) => 'rgba(' + canvas_color[d.status] + ')') //; //status_color[d.status]);
                .attr('fillStyleHidden', function(d) {
                    if (!d.hiddenCol) {
                        d.hiddenCol = genColor();
                        colourToNode[d.hiddenCol] = d;
                    }
                    // Here you (1) add a unique colour as property to each element 
                    // and(2) map the colour to the node in the colourToNode-map.
                    return d.hiddenCol;
                });
        }

        function drawAxis(canvas, grid_size = 20) {
            var ctx = canvas.node().getContext('2d');

            var padding = 2;
            var tickCount;
            var tickSize = 6;
            var ticks_x = xscale.ticks(tickCount);
            var ticks_y = yscale.ticks(tickCount);

            ctx.lineWidth = 1;
            ctx.strokeStyle = "black";
            ctx.fillStyle = "black";
            ctx.font = "normal 10px sans-serif";

            // x axis
            ctx.beginPath();
            // draw ticks
            ticks_x.forEach(function(d) {
                ctx.moveTo(xscale(d), height + padding - tickSize / 2);
                ctx.lineTo(xscale(d), height + padding + tickSize / 2);
            });
            ctx.stroke();
            // draw axis line
            ctx.beginPath();
            ctx.moveTo(-2 * padding, height + padding + tickSize / 2);
            ctx.lineTo(width, height + padding + tickSize / 2);
            ctx.stroke();
            //draw legend
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ticks_x.forEach(function(d) {
                ctx.fillText(d, xscale(d), height + padding + tickSize + 1);
            });

            // y axis
            ctx.beginPath();
            // draw ticks
            ticks_y.forEach(function(d) {
                ctx.moveTo(tickSize / 2, yscale(d));
                ctx.lineTo(-tickSize / 2, yscale(d));
            });
            ctx.stroke();
            // draw axis line
            ctx.beginPath();
            ctx.moveTo(-padding - tickSize / 2, margin.top - 1);
            ctx.lineTo(-padding - tickSize / 2, height + 3 * padding);
            ctx.stroke();
            // draw legend
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            ticks_y.forEach(function(d) {
                ctx.fillText(d, -2 * padding - tickSize, yscale(d));
            });

            ctx.font = "bold 12px sans-serif";
            ctx.fillText("x" + curXDim, width, margin.top + height + margin.bottom / 2);
            ctx.fillText("y" + curYDim, -margin.left / 2, margin.top + tickSize);
        }

        function draw(canv, hidden = false) {
            var context = canv.node().getContext('2d');
            context.clearRect(-margin.left, -margin.top, canv.node().width + margin.left, canv.node().height + margin.top); // Clear the canvas.
            // Draw each individual custom element with their properties.

            drawAxis(canv);

            var boxes = custom.selectAll('custom.box');
            // Grab all elements you bound data to in the databind() function.
            boxes.each(function(d, i) { // For each virtual/custom element...
                var node = d3.select(this);
                // This is each individual element in the loop. 
                //context.fillStyle = node.attr('fillStyle');
                context.fillStyle = hidden ? node.attr('fillStyleHidden') : node.attr('fillStyle');
                // The node colour depends on the canvas you draw.
                //console.log(hidden + " ? " + node.attr('fillStyleHidden') + " : " + node.attr('fillStyle') + " = " + (hidden ? node.attr('fillStyleHidden') : node.attr('fillStyle')));
                // Here you retrieve the colour from the individual in-memory node and set the fillStyle for the canvas paint
                context.fillRect(node.attr('x') + margin.left, node.attr('y') + margin.top, node.attr('width'), node.attr('height'));
                //console.log(node.attr('x') + "x" + node.attr('y') + ", " + node.attr('width') + "x" + node.attr('height'));
                // Here you retrieve the position of the node and apply it to the fillRect context function which will fill and paint the square.
            }); // Loop through each element.
        }



        // Add inputs to update the graphic
        function create_controls(node) {
            node.selectAll("*").remove();

            // Add a list selection for dimension of x axis
            var selX = node.append('select')
                .attr("id", "selX")
                .style("font-size", "14")
                .attr('class', 'select')
                .on('change', onchangeX);
            selX.selectAll("option")
                .data(var_names).enter()
                .append('option')
                .property('selected', function(d) {
                    return d === var_names[0];
                })
                .text(function(d) {
                    return d;
                })
            // Add a list selection for dimension of y axis
            var selY = node.append('select')
                .attr("id", "selY")
                .attr('class', 'select')
                .on('change', onchangeY);
            selY.selectAll("option")
                .data(var_names).enter()
                .append('option')
                .property('selected', function(d) {
                    return d === var_names[1];
                })
                .text(function(d) {
                    return d;
                });

            // Add a list selection for the status of solutions to plot
            var selStatus = node.append('select')
                .attr("id", "selStatus")
                .attr('class', 'select')
                .on('change', onchangeStatus);
            selStatus.selectAll("option")
                .data(status_names).enter()
                .append('option')
                .property('selected', function(d) {
                    return d === "Inner";
                })
                .text(function(d) {
                    return d;
                });

            var grpBtn = node.append('div').attr("class", 'input-group margin-bottom-sm');


            var crop = grpBtn.append('span')
                .attr('id', 'crop')
                .attr('title', 'Make a rectangular selection')
                .attr('type', 'button')
                //.attr('value', '&#f125')
                .on('click', crop)
                .append('i')
                .attr('class', 'fas fa-crop fa-2x fa-border');

            var zoomIn = grpBtn.append('span')
                .attr('id', 'zoomIn')
                .attr('title', 'Zoom in')
                .on('click', zoom_in)
                .append('i')
                .attr('class', 'fas fa-search-plus fa-2x fa-border');
            var zoomOut = grpBtn.append('span')
                .attr('id', 'zoomOut')
                .attr('title', 'Zoom out')
                .on('click', zoom_out)
                .append('i')
                .attr('class', 'fas fa-search-minus fa-2x fa-border');

            var resSel = grpBtn.append('span')
                .attr('id', 'resBtn')
                .attr('title', 'Reset current selection or zoom')
                .on('click', reset_selection)
                .append('i')
                .attr('class', 'fas fa-undo fa-2x fa-border');

            var expImg = grpBtn.append('span')
                .attr('id', 'expImg')
                .attr('title', 'Export current graphic as image')
                .on('click', export_image)
                .append('i')
                .attr('class', 'fas fa-image fa-2x fa-border');

            var expMnf = grpBtn.append('span')
                .attr('id', 'expMnf')
                .attr('title', 'Export current boxes as manifold')
                .on('click', export_manifold)
                .append('i')
                .attr('class', 'fas fa-save fa-2x fa-border');


            // function called when dimension for x axis change
            function onchangeX() {
                var selectValue = d3.select('#selX').property('value');
                // get the number corresponding to the selection
                curXDim = parseInt(selectValue.substring(1));

                var minAcc = function(d) {
                    return d.lowers[curXDim];
                };
                var maxAcc = function(d) {
                    return d.uppers[curXDim];
                };
                x_dom[0] = d3.extent(plotted_sols, minAcc)[0];
                x_dom[1] = d3.extent(plotted_sols, maxAcc)[1];

                //reset_selection();
                // add new data relating to new selected dimension
                update_plot_info();

                data_bind(plotted_sols);
                draw(canvas);
                draw(hiddenCanvas, true);
            };

            // function called when dimension for y axis change
            function onchangeY() {
                var selectValue = d3.select('#selY').property('value');
                // get the number corresponding to the selection
                curYDim = parseInt(selectValue.substring(1));

                var minAcc = function(d) {
                    return d.lowers[curYDim];
                };
                var maxAcc = function(d) {
                    return d.uppers[curYDim];
                };
                y_dom[0] = d3.extent(plotted_sols, minAcc)[0];
                y_dom[1] = d3.extent(plotted_sols, maxAcc)[1];

                //reset_selection();
                // add new data relating to new selected dimension
                update_plot_info();


                data_bind(plotted_sols);
                draw(canvas);
                draw(hiddenCanvas, true);
            };

            // function called when status change
            function onchangeStatus() {
                var selectValue = d3.select('#selStatus').property('value');
                if (selectValue === "All") {
                    // remove current filter from selected solutions
                    filter_by_status.filterAll();
                } else {
                    // filter solutions on selected status
                    filter_by_status.filterExact(status_codes[selectValue]);
                }
                // update the set of solution to plot
                plotted_sols = filter_by_status.top(Infinity);
                //d3.select("#info").html(plotted_sols.length + " solutions displayed");

                var minAcc = function(d) {
                    return d.lowers[curXDim];
                };
                var maxAcc = function(d) {
                    return d.uppers[curXDim];
                };
                x_dom[0] = d3.extent(plotted_sols, minAcc)[0];
                x_dom[1] = d3.extent(plotted_sols, maxAcc)[1];

                //reset_selection();
                // add new data relating to new selected status
                update_plot_info();

                data_bind(plotted_sols);
                draw(canvas);
                draw(hiddenCanvas, true);
            };


            function crop() {
                // TODO

            }


            function zoom_in() {
                var w_x = x_dom[1] - x_dom[0];
                var w_y = y_dom[1] - y_dom[0];
                x_dom[0] += w_x * k_zoom;
                x_dom[1] -= w_x * k_zoom;
                y_dom[0] += w_y * k_zoom;
                y_dom[1] -= w_y * k_zoom;

                filter_sol.filterFunction(function(d) {
                    //return d.lowers[curXDim] >= x_dom[0] && d.uppers[curXDim] <= x_dom[1] && d.lowers[curYDim] >= y_dom[0] && d.uppers[curYDim] <= y_dom[1];
                    return ((d.lowers[curXDim] >= x_dom[0] && d.lowers[curXDim] <= x_dom[1]) ||
                            (d.uppers[curXDim] <= x_dom[1] && d.uppers[curXDim] >= x_dom[0])) &&
                        ((d.lowers[curYDim] >= y_dom[0] && d.lowers[curYDim] <= y_dom[1]) ||
                            (d.uppers[curYDim] <= y_dom[1] && (d.uppers[curYDim] >= y_dom[0])));
                });

                // update the set of solution to plot
                plotted_sols = filter_sol.top(Infinity);
                d3.select("#info").html(plotted_sols.length + " solutions displayed");

                //reset_selection();
                // add new data relating to new selected status
                update_plot_info();

                data_bind(plotted_sols);
                draw(canvas);
                draw(hiddenCanvas, true);
            }


            function zoom_out() {
                var w_x = x_dom[1] - x_dom[0];
                var w_y = y_dom[1] - y_dom[0];
                x_dom[0] -= w_x * k_zoom;
                x_dom[1] += w_x * k_zoom;
                y_dom[0] -= w_y * k_zoom;
                y_dom[1] += w_y * k_zoom;

                filter_sol.filterFunction(function(d) {
                    //return d.lowers[curXDim] >= x_dom[0] && d.uppers[curXDim] <= x_dom[1] && d.lowers[curYDim] >= y_dom[0] && d.uppers[curYDim] <= y_dom[1];
                    return ((d.lowers[curXDim] >= x_dom[0] && d.lowers[curXDim] <= x_dom[1]) ||
                            (d.uppers[curXDim] <= x_dom[1] && d.uppers[curXDim] >= x_dom[0])) &&
                        ((d.lowers[curYDim] >= y_dom[0] && d.lowers[curYDim] <= y_dom[1]) ||
                            (d.uppers[curYDim] <= y_dom[1] && (d.uppers[curYDim] >= y_dom[0])));
                });

                // update the set of solution to plot
                plotted_sols = filter_sol.top(Infinity);
                d3.select("#info").html(plotted_sols.length + " solutions displayed");
                //reset_selection();
                // add new data relating to new selected status
                update_plot_info();

                data_bind(plotted_sols);
                draw(canvas);
                draw(hiddenCanvas, true);
            }


            function downloadURL(data, fileName) {
                var a;
                a = document.createElement('a');
                a.href = data;
                a.download = fileName;
                document.body.appendChild(a);
                a.style = 'display: none';
                a.click();
                a.remove();
            };

            function export_image() {
                var img = d3.select("#canvas_plot").node().toDataURL("image/png");
                downloadURL(img, "plot.png");
                //get svg element.
                /*var svg = d3.select("#plot_0").node();
                console.log("Export current graphic as svg file");
                //get svg source.
                var serializer = new XMLSerializer();
                var source = serializer.serializeToString(svg);

                //add name spaces.
                if (!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
                    source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
                }
                if (!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)) {
                    source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
                }

                //add xml declaration
                source = '<?xml version="1.0" standalone="no"?>\r\n' + source;

                //convert svg source to URI data scheme.
                var url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);

                //set url value to a element's href attribute.
                /*var link = d3.select("#info").append("a").attr("href", url).attr("download", "plot.svg"); //.html("download image");
                //document.getElementById("link").href = url;
                //you can download svg file by right click menu.
                link.node().click();
                link.remove();*/
                //downloadURL(url, "plot.svg")
            }

            function export_manifold() {
                var sig_str = "IBEX MANIFOLD FILE ";
                var n_int = 11 + plotted_sols.length;
                var n_dbl = 1 + 2 * plotted_sols.length * plotted_sols[0].lowers.length;
                var n_bytes = sig_str.length + 4 * n_int + 8 * n_dbl;
                var buffer = new ArrayBuffer(n_bytes);
                var view = new DataView(buffer);

                var cursor = 0;
                for (var i = 0; i < sig_str.length; i++) {
                    view.setUint8(i, sig_str.charCodeAt(i))
                }
                cursor = sig_str.length + 1;

                view.setUint32(cursor, 2 >>> 0, true); // mnf ver
                cursor += 4;
                view.setUint32(cursor, plotted_sols[0].lowers.length >>> 0, true); // nb var
                cursor += 4;
                view.setUint32(cursor, plotted_sols[0].lowers.length >>> 0, true); // nb eq
                cursor += 4;
                view.setUint32(cursor, 0 >>> 0, true); // nb ineq
                cursor += 4;
                view.setUint32(cursor, 0 >>> 0, true); // search status
                cursor += 4;
                view.setUint32(cursor, 0 >>> 0, true); // nb inner
                cursor += 4;
                view.setUint32(cursor, 0 >>> 0, true); // nb boundary
                cursor += 4;
                view.setUint32(cursor, plotted_sols.length >>> 0, true); // nb unkown
                cursor += 4;
                view.setUint32(cursor, 0 >>> 0, true); // nb pending
                cursor += 4;
                view.setFloat64(cursor, 2.5, true); // time
                cursor += 8;
                view.setUint32(cursor, 0 >>> 0, true); // nb cells
                cursor += 4;
                var k = 0;
                for (let sol of plotted_sols) {
                    k += 1;
                    for (var i = 0; i < sol.lowers.length; i++) {
                        view.setFloat64(cursor, sol.lowers[i], true);
                        cursor += 8;
                        view.setFloat64(cursor, sol.uppers[i], true);
                        cursor += 8;
                    }
                    view.setUint32(cursor, 3 >>> 0, true); // box status: Pending
                    cursor += 4;
                }

                function downloadBlob(data, fileName, mimeType) {
                    var blob, url;
                    blob = new Blob([data], {
                        type: mimeType
                    });
                    console.log("Blob length: " + blob.size);
                    url = window.URL.createObjectURL(blob);
                    downloadURL(url, fileName, mimeType);
                    setTimeout(function() {
                        return window.URL.revokeObjectURL(url);
                    }, 1000);
                };

                console.log("Buffer length: " + buffer.byteLength, " : " + cursor);

                downloadBlob(buffer, 'plot.mnf', 'application/octet-stream');
            }

        }

        // Function that handle the manifold file drop
        function drop_handler(ev) {
            ev.preventDefault();
            console.log("Drop");
            // If dropped items aren't files, reject them
            var dt = ev.dataTransfer;
            if (dt.items) {
                // Use DataTransferItemList interface to access the file(s)
                for (var i = 0; i < dt.items.length; i++) {
                    if (dt.items[i].kind == "file") {
                        // Remove previous elements if a drawing exists
                        d3.select("#explorer").selectAll("select").remove();
                        d3.select("#explorer").selectAll("input").remove();

                        // Process the ith file, normally only 1 file to process
                        var f = dt.items[i].getAsFile();
                        var reader = new FileReader();

                        // Function called after data loading achieved
                        reader.onloadend = function() {
                            if (parse_data_ibex(reader.result) == 1) {

                            } else {
                                console.log("Wrong file format!");
                            }

                            // Initialize crossfilter with read solutions
                            cf = crossfilter(sols);

                            // create filters
                            filter_sol = cf.dimension(function(d) {
                                return d;
                            });
                            filter_by_status = cf.dimension(function(d) {
                                return d.status;
                            });
                            // start with inner solutions only
                            filter_by_status.filterExact(0);
                            plotted_sols = filter_by_status.top(Infinity);
                            console.log(plotted_sols.length + " filtered solutions");

                            create_controls(d3.select("#control"));

                            create_plot();
                        }

                        reader.readAsArrayBuffer(f);
                    }
                }
            } else {
                // Use DataTransfer interface to access the file(s)
                for (var i = 0; i < dt.files.length; i++) {
                    console.log("... file[" + i + "].name = " + dt.files[i].name);
                }
            }
        }

        function dragover_handler(ev) {
            // Prevent default select and drag behavior
            ev.preventDefault();
        }

        function dragend_handler(ev) {
            // Remove all of the drag data
            var dt = ev.dataTransfer;
            if (dt.items) {
                // Use DataTransferItemList interface to remove the drag data
                for (var i = 0; i < dt.items.length; i++) {
                    dt.items.remove(i);
                }
            } else {
                // Use DataTransfer interface to remove the drag data
                ev.dataTransfer.clearData();
            }
        }

    </script>
</body>

</html>
